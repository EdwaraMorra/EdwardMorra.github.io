<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Virtual Tour</title>

    <!-- Three.js Module Import -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* UI Components Styles */
        .card {
            background: white;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .card-header {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            line-height: 1;
            letter-spacing: -0.025em;
        }

        .card-content {
            padding: 1.5rem;
            padding-top: 0;
        }

        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            border: none;
            cursor: pointer;
            gap: 0.5rem;
        }

        .button:disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .button-default {
            background: #2563eb;
            color: white;
        }

        .button-default:hover {
            background: #1d4ed8;
        }

        .button-destructive {
            background: #dc2626;
            color: white;
        }

        .button-destructive:hover {
            background: #b91c1c;
        }

        .button-outline {
            background: transparent;
            border: 1px solid #d1d5db;
            color: inherit;
        }

        .button-outline:hover {
            background: #f9fafb;
        }

        .button-ghost {
            background: transparent;
            color: inherit;
            border: none;
        }

        .button-ghost:hover {
            background: #f9fafb;
        }

        .button-sm {
            height: 2.25rem;
            padding: 0 0.75rem;
            font-size: 0.875rem;
        }

        .button-default-size {
            height: 2.5rem;
            padding: 0 1rem;
        }

        .space-y-2 > * + * {
            margin-top: 0.5rem;
        }

        .space-y-3 > * + * {
            margin-top: 0.75rem;
        }

        .space-x-2 > * + * {
            margin-left: 0.5rem;
        }

        .flex {
            display: flex;
        }

        .items-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .w-full {
            width: 100%;
        }

        .w-80 {
            width: 20rem;
        }

        .h-8 {
            height: 2rem;
        }

        .h-9 {
            height: 2.25rem;
        }

        .h-10 {
            height: 2.5rem;
        }

        .w-8 {
            width: 2rem;
        }

        .p-0 {
            padding: 0;
        }

        .p-2 {
            padding: 0.5rem;
        }

        .p-4 {
            padding: 1rem;
        }

        .text-sm {
            font-size: 0.875rem;
        }

        .text-xs {
            font-size: 0.75rem;
        }

        .text-lg {
            font-size: 1.125rem;
        }

        .text-xl {
            font-size: 1.25rem;
        }

        .font-medium {
            font-weight: 500;
        }

        .font-semibold {
            font-weight: 600;
        }

        .text-gray-600 {
            color: #4b5563;
        }

        .text-gray-800 {
            color: #1f2937;
        }

        .text-blue-600 {
            color: #2563eb;
        }

        .text-blue-800 {
            color: #1e40af;
        }

        .bg-white {
            background: white;
        }

        .bg-blue-50 {
            background: #eff6ff;
        }

        .bg-blue-100 {
            background: #dbeafe;
        }

        .bg-gray-200 {
            background: #e5e7eb;
        }

        .bg-blue-600 {
            background: #2563eb;
        }

        .bg-black {
            background: black;
        }

        .bg-opacity-50 {
            opacity: 0.5;
        }

        .bg-opacity-90 {
            opacity: 0.9;
        }

        .rounded {
            border-radius: 0.25rem;
        }

        .rounded-full {
            border-radius: 9999px;
        }

        .rounded-lg {
            border-radius: 0.5rem;
        }

        .border {
            border: 1px solid #e5e7eb;
        }

        .border-2 {
            border-width: 2px;
        }

        .border-blue-200 {
            border-color: #bfdbfe;
        }

        .border-blue-500 {
            border-color: #3b82f6;
        }

        .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .absolute {
            position: absolute;
        }

        .relative {
            position: relative;
        }

        .inset-0 {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        .top-4 {
            top: 1rem;
        }

        .left-4 {
            left: 1rem;
        }

        .z-10 {
            z-index: 10;
        }

        .z-20 {
            z-index: 20;
        }

        .z-30 {
            z-index: 30;
        }

        .z-40 {
            z-index: 40;
        }

        .pointer-events-none {
            pointer-events: none;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        .cursor-pointer {
            cursor: pointer;
        }

        .transform {
            transform: translate(var(--tw-translate-x), var(--tw-translate-y));
        }

        .-translate-x-1-2 {
            transform: translateX(-50%);
        }

        .-translate-y-1-2 {
            transform: translateY(-50%);
        }

        .transition-all {
            transition: all 0.2s;
        }

        .duration-200 {
            transition-duration: 200ms;
        }

        .duration-300 {
            transition-duration: 300ms;
        }

        .hidden {
            display: none;
        }

        .block {
            display: block;
        }

        .flex-1 {
            flex: 1;
        }

        .max-w-90vw {
            max-width: 90vw;
        }

        .max-w-sm {
            max-width: 24rem;
        }

        .h-2 {
            height: 0.5rem;
        }

        .h-screen {
            height: 100vh;
        }

        .touch-none {
            touch-action: none;
        }

        .overflow-hidden {
            overflow: hidden;
        }

        .leading-relaxed {
            line-height: 1.625;
        }

        .mt-1 {
            margin-top: 0.25rem;
        }

        .mb-4 {
            margin-bottom: 1rem;
        }

        .hover-bg-opacity-100:hover {
            opacity: 1;
        }

        input[type="range"] {
            width: 100%;
            height: 0.375rem;
            border-radius: 0.25rem;
            background: #d1d5db;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
        }

        .progress-bar {
            width: 100%;
            background: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #2563eb;
            transition: width 0.2s;
        }

        .status-loading {
            background: rgba(255, 193, 7, 0.2);
            color: #ffa000;
            border-left: 4px solid #ffc107;
        }

        .status-success {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border-left: 4px solid #4caf50;
        }

        .status-error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border-left: 4px solid #f44336;
        }

        /* Simple icon styles */
        .icon {
            width: 1rem;
            height: 1rem;
            display: inline-block;
        }

        .icon-upload::before {
            content: 'üì§';
        }

        .icon-rotate-ccw::before {
            content: 'üîÑ';
        }

        .icon-play::before {
            content: '‚ñ∂Ô∏è';
        }

        .icon-pause::before {
            content: '‚è∏Ô∏è';
        }

        .icon-eye::before {
            content: 'üëÅÔ∏è';
        }

        .icon-x::before {
            content: '‚ùå';
        }

        .icon-map-pin::before {
            content: 'üìç';
        }

        .icon-chevron-up::before {
            content: '‚Üë';
        }

        .icon-chevron-down::before {
            content: '‚Üì';
        }

        /* Hint Modal Styles */
        #hint-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(4px);
        }

        .hint-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            padding: 0;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            overflow: hidden;
        }

        .hint-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .hint-modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #1f2937;
        }

        .hint-modal-subtitle {
            font-size: 1rem;
            color: #6b7280;
        }

        .hint-modal-body {
            padding: 1.5rem;
            line-height: 1.6;
            color: #374151;
        }

        .hint-modal-footer {
            padding: 1rem 1.5rem 1.5rem;
            display: flex;
            justify-content: flex-end;
        }

        .hint-modal-close-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .hint-modal-close-btn:hover {
            background: #1d4ed8;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- 2D Hint Icons Overlay -->
    <div id="hints-overlay" class="absolute inset-0 pointer-events-none z-30"></div>

    <!-- Control Panel -->
    <div id="control-panel" class="absolute top-4 left-4 z-20 transition-all duration-300 w-80 max-w-90vw">
        <div class="card relative">
            <div class="card-header pb-2">
                <div class="flex items-center justify-between">
                    <h3 class="card-title text-lg" id="panel-title">3D Tour Controls</h3>
                    <button id="collapse-btn" class="button button-ghost h-8 w-8 p-0">
                        <span class="icon icon-chevron-up"></span>
                    </button>
                </div>
            </div>

            <div id="panel-content" class="card-content space-y-3">
                <!-- Mobile gyroscope permission -->
                <div id="gyro-prompt" class="space-y-2 hidden">
                    <button id="enable-gyro-btn" class="button button-outline w-full text-sm">
                        üéØ Enable Gyroscope Control
                    </button>
                </div>

                <!-- Mobile status indicator -->
                <div id="mobile-status" class="text-xs bg-blue-50 p-2 rounded border border-blue-200 hidden">
                    <p class="font-medium text-blue-800">üì± Mobile Mode Active</p>
                    <p id="gyro-status" class="text-blue-600">‚ö†Ô∏è Gyroscope disabled</p>
                </div>

                <!-- Map loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Load Map/Environment:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json,.glb,.gltf" id="map-upload" class="hidden">
                        <button id="load-map-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-upload"></span>
                            <span>Load Map</span>
                        </button>
                    </div>
                    <!-- Status for GLTF loading -->
                    <div id="map-load-status" class="text-xs p-2 rounded hidden"></div>
                </div>

                <!-- Path loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Camera Path:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json" id="path-upload" class="hidden">
                        <button id="load-path-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-upload"></span>
                            <span>Load Path</span>
                        </button>
                        <button id="sample-path-btn" class="button button-outline button-sm text-xs">
                            Sample Path
                        </button>
                    </div>
                </div>

                <!-- Hints loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Hints:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json" id="hint-upload" class="hidden">
                        <button id="load-hints-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-map-pin"></span>
                            <span>Load Hints</span>
                        </button>
                        <button id="sample-hints-btn" class="button button-outline button-sm text-xs">
                            Sample Hints
                        </button>
                    </div>
                </div>

                <!-- Hint settings -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Hint Settings:</label>
                    <div class="space-y-2">
                        <button id="toggle-hints-btn" class="button button-outline button-sm w-full text-xs">
                            Show All Hints
                        </button>
                        <div class="flex items-center space-x-2">
                            <label class="text-xs">Distance:</label>
                            <input type="range" min="5" max="50" value="15" id="hint-distance-slider" class="flex-1">
                            <span id="hint-distance-value" class="text-xs w-8">15</span>
                        </div>
                    </div>
                </div>

                <!-- Path controls -->
                <div id="path-controls" class="space-y-2 hidden">
                    <label class="block text-sm font-medium">Path Progress: <span id="progress-percent">0</span>%</label>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
                    </div>

                    <div class="space-y-2">
                        <label class="block text-sm font-medium">Scrolling Speed:</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs w-8">0.1x</span>
                            <input type="range" min="0.1" max="3.0" step="0.1" value="1.0" id="speed-slider" class="flex-1">
                            <span class="text-xs w-8">3.0x</span>
                        </div>
                        <div class="text-center">
                            <span id="speed-display" class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">1.0x speed</span>
                        </div>
                    </div>

                    <!-- Path Smoothing Control -->
                    <div class="space-y-2">
                        <label class="block text-sm font-medium">Path Smoothing:</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs w-8">Low</span>
                            <input type="range" min="0.0" max="1.0" step="0.1" value="0.5" id="smoothing-slider" class="flex-1">
                            <span class="text-xs w-8">High</span>
                        </div>
                        <div class="text-center">
                            <span id="smoothing-display" class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">Medium smoothing</span>
                        </div>
                    </div>

                    <div class="flex space-x-2">
                        <button id="play-btn" class="button button-default button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-play"></span>
                            <span>Play</span>
                        </button>
                        <button id="reset-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-rotate-ccw"></span>
                            <span>Reset</span>
                        </button>
                    </div>
                </div>

                <!-- Instructions -->
                <div class="text-xs text-gray-600 space-y-1">
                    <p><strong>üñ±Ô∏è Mouse:</strong> Move to look around (click to lock pointer)</p>
                    <p><strong>üé° Mouse Wheel:</strong> Navigate along path (infinite loop)</p>
                    <p><strong>üí° Hints:</strong> Click 2D icons to view information</p>
                    <p><strong>üö´ No Page Scroll:</strong> All scrolling disabled</p>
                    <p><strong>‚ö° Speed Control:</strong> Adjust scrolling speed (0.1x - 3.0x)</p>
                    <p><strong>üîÑ Path Smoothing:</strong> Control how smooth the path is between points</p>
                    <p><strong>üó∫Ô∏è Map Format:</strong> GLB, GLTF files supported</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Hint Modal -->
    <div id="hint-modal">
        <div class="hint-modal-content">
            <div class="hint-modal-header">
                <h2 id="hint-modal-title" class="hint-modal-title">Hint Title</h2>
                <p id="hint-modal-subtitle" class="hint-modal-subtitle">Hint Subtitle</p>
            </div>
            <div class="hint-modal-body">
                <p id="hint-modal-text">Hint text content will appear here when you click on a hint icon.</p>
            </div>
            <div class="hint-modal-footer">
                <button id="hint-modal-close-btn" class="hint-modal-close-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 z-40">
        <div class="text-white text-xl">Loading 3D Scene...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Main application
        class VirtualTour {
            constructor() {
                this.scene = null;
                this.renderer = null;
                this.camera = null;
                this.gltfLoader = null;

                // Camera system
                this.body = null;
                this.path = [];
                this.curve = null;
                this.currentProgress = 0;
                this.velocity = 0;
                this.isPlaying = false;

                // Camera rotation
                this.pitch = 0;
                this.yaw = 0;
                this.isPointerLocked = false;

                this.hints = [];
                this.visibleHints = [];

                // Current model
                this.currentModel = null;
                this.modelOffset = new THREE.Vector3(0, 0, 0);

                // Mobile-specific
                this.isMobile = false;
                this.gyroscopeSupported = false;
                this.gyroscopePermission = 'prompt';
                this.gyroscopeData = { alpha: 0, beta: 0, gamma: 0 };

                // Settings
                this.scrollingSpeed = 1.0;
                this.showAllHints = false;
                this.hintVisibilityDistance = 15;
                this.pathSmoothing = 0.5;

                // Modal state
                this.isModalOpen = false;

                // DOM elements
                this.canvasContainer = document.getElementById('canvas-container');
                this.hintsOverlay = document.getElementById('hints-overlay');
                this.controlPanel = document.getElementById('control-panel');
                this.mapLoadStatus = document.getElementById('map-load-status');
                this.hintModal = document.getElementById('hint-modal');

                // Inertia parameters
                this.acceleration = 0.0005;
                this.deceleration = 0.95;
                this.maxSpeed = 0.02;

                this.init();
            }

            init() {
                this.detectMobile();
                this.setupEventListeners();
                this.initThreeJS();
                this.loadDefaultMap();
                this.updateUI();
            }

            detectMobile() {
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                              (window.innerWidth <= 768);

                if (this.isMobile && 'DeviceOrientationEvent' in window) {
                    this.gyroscopeSupported = true;
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        this.gyroscopePermission = 'prompt';
                    } else {
                        this.gyroscopePermission = 'granted';
                    }
                }

                // Update UI for mobile
                if (this.isMobile) {
                    document.getElementById('panel-title').textContent += ' üì±';
                    document.getElementById('gyro-prompt').classList.remove('hidden');
                    document.getElementById('mobile-status').classList.remove('hidden');

                    // Update instructions for mobile
                    const instructions = document.querySelector('.text-xs.text-gray-600');
                    instructions.innerHTML = `
                        <p><strong>üì± Gyroscope:</strong> Tilt device to look around</p>
                        <p><strong>üëÜ Touch Scroll:</strong> Swipe vertically to navigate path</p>
                        <p><strong>üí° Hints:</strong> Tap 2D icons to view information</p>
                        <p><strong>üö´ No Page Scroll:</strong> All scrolling disabled</p>
                        <p><strong>‚ö° Speed Control:</strong> Adjust scrolling speed (0.1x - 3.0x)</p>
                        <p><strong>üîÑ Path Smoothing:</strong> Control how smooth the path is between points</p>
                        <p><strong>üó∫Ô∏è Map Format:</strong> GLB, GLTF files supported</p>
                    `;
                }
            }

            setupEventListeners() {
                // File uploads
                document.getElementById('load-map-btn').addEventListener('click', () => {
                    document.getElementById('map-upload').click();
                });
                document.getElementById('load-path-btn').addEventListener('click', () => {
                    document.getElementById('path-upload').click();
                });
                document.getElementById('load-hints-btn').addEventListener('click', () => {
                    document.getElementById('hint-upload').click();
                });

                document.getElementById('map-upload').addEventListener('change', (e) => this.handleMapLoad(e));
                document.getElementById('path-upload').addEventListener('change', (e) => this.handlePathLoad(e));
                document.getElementById('hint-upload').addEventListener('change', (e) => this.handleHintLoad(e));

                // Buttons
                document.getElementById('sample-path-btn').addEventListener('click', () => this.generateSamplePath());
                document.getElementById('sample-hints-btn').addEventListener('click', () => this.generateSampleHints());
                document.getElementById('enable-gyro-btn').addEventListener('click', () => this.requestGyroscopePermission());
                document.getElementById('toggle-hints-btn').addEventListener('click', () => this.toggleShowAllHints());
                document.getElementById('play-btn').addEventListener('click', () => this.togglePlay());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetCamera());
                document.getElementById('collapse-btn').addEventListener('click', () => this.toggleUICollapse());
                document.getElementById('hint-modal-close-btn').addEventListener('click', () => this.closeHintModal());

                // Sliders
                document.getElementById('hint-distance-slider').addEventListener('input', (e) => {
                    this.hintVisibilityDistance = parseInt(e.target.value);
                    document.getElementById('hint-distance-value').textContent = this.hintVisibilityDistance;
                });

                document.getElementById('speed-slider').addEventListener('input', (e) => {
                    this.scrollingSpeed = parseFloat(e.target.value);
                    document.getElementById('speed-display').textContent = this.scrollingSpeed + 'x speed';
                });

                // Path smoothing slider
                document.getElementById('smoothing-slider').addEventListener('input', (e) => {
                    this.pathSmoothing = parseFloat(e.target.value);
                    this.updateSmoothingDisplay();
                    // Update path with new smoothing
                    if (this.path.length > 0) {
                        this.setPathFromData({ points: this.path });
                    }
                });
            }

            updateSmoothingDisplay() {
                let smoothingText;
                if (this.pathSmoothing < 0.3) {
                    smoothingText = "Low smoothing";
                } else if (this.pathSmoothing < 0.7) {
                    smoothingText = "Medium smoothing";
                } else {
                    smoothingText = "High smoothing";
                }
                document.getElementById('smoothing-display').textContent = smoothingText;
            }

            initThreeJS() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);

                // Create body that moves along the path
                this.body = new THREE.Object3D();
                this.scene.add(this.body);

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    this.canvasContainer.clientWidth / this.canvasContainer.clientHeight,
                    0.1,
                    1000
                );
                this.body.add(this.camera);
                this.camera.position.set(0, 0, 0);

                // Set camera rotation order to prevent roll
                this.camera.rotation.order = 'YXZ';

                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.canvasContainer.appendChild(this.renderer.domElement);

                // GLTF Loader
                this.gltfLoader = new GLTFLoader();

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 1024;
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.camera.near = 0.1;
directionalLight.shadow.camera.far = 500;
directionalLight.shadow.camera.left = -500;
directionalLight.shadow.camera.right = 500;
directionalLight.shadow.camera.top = 20;
directionalLight.shadow.camera.bottom = -2
                this.scene.add(directionalLight);

                // Setup controls
                this.setupControls();

                // Start animation loop
                this.animate();

                // Hide loading overlay
                document.getElementById('loading-overlay').classList.add('hidden');
            }

            loadDefaultMap() {
                // Load default map from map.glb
                this.updateMapLoadStatus('Loading default map...', 'loading');

                this.gltfLoader.load(
                    'map.glb',

                    // onLoad callback
                    (gltf) => {
                        // Remove previous model if exists
                        if (this.currentModel) {
                            this.scene.remove(this.currentModel);
                        }

                        const model = gltf.scene;
                        this.currentModel = model;

                        // Configure the model
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // Calculate model bounding box and center
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());

                        // Calculate the offset needed to center the model
                        this.modelOffset = center.clone().multiplyScalar(-1);

                        // Center the model at origin
                        model.position.copy(this.modelOffset);

                        // Add to scene
                        this.scene.add(model);

                        // Load default path after map is loaded
                        this.loadDefaultPath();

                        // Update status
                        this.updateMapLoadStatus(`Default map loaded successfully! Size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'success');
                    },

                    // onProgress callback
                    (xhr) => {
                        if (xhr.lengthComputable) {
                            const percentComplete = (xhr.loaded / xhr.total * 100).toFixed(2);
                            this.updateMapLoadStatus(`Loading default map: ${percentComplete}%`, 'loading');
                        }
                    },

                    // onError callback
                    (error) => {
                        console.error('Error loading default map:', error);
                        this.updateMapLoadStatus('Default map not found. You can load a map manually.', 'error');
                        // Load default path even if map fails
                        this.loadDefaultPath();
                    }
                );
            }

            loadDefaultPath() {
                // Load default path from path.json
                fetch('path.json')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Path file not found');
                        }
                        return response.json();
                    })
                    .then(data => {
                        this.setPathFromData(data);
                    })
                    .catch(error => {
                        console.error('Error loading default path:', error);
                        // Generate sample path if default path not found
                        this.generateSamplePath();
                    });
            }

            setPathFromData(pathData) {
                // Clear existing path visualization
                if (this.pathLine) {
                    this.scene.remove(this.pathLine);
                }

                // Convert points to Vector3 with high precision
                const points = pathData.points.map(p => {
                    return new THREE.Vector3(
                        parseFloat(p.x.toFixed(15)),
                        parseFloat(p.y.toFixed(15)),
                        parseFloat(p.z.toFixed(15))
                    );
                });

                // Apply model offset to align path with model
                const adjustedPoints = points.map(point =>
                    point.clone().add(this.modelOffset)
                );

                // Create curve from points with adjustable smoothing
                this.curve = this.createSmoothCurve(adjustedPoints);

                // Check if curve was created successfully
                if (!this.curve) {
                    console.error('Failed to create path curve');
                    return;
                }

                // Create visualization
                const pathGeometry = new THREE.BufferGeometry().setFromPoints(this.curve.getPoints(500));
                const pathMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                this.pathLine = new THREE.Line(pathGeometry, pathMaterial);
                  // this.scene.add(this.pathLine);

                // Set initial position
                if (points.length > 0) {
                    const initialPoint = this.curve.getPoint(0);
                    this.body.position.copy(initialPoint);

                    // Look along the path
                    const lookAtPoint = this.curve.getPoint(0.01);
                    this.body.lookAt(lookAtPoint);
                }

                this.updateUI();
            }

            createSmoothCurve(points) {
                // Check if we have enough points
                if (points.length < 2) {
                    console.warn('Not enough points to create curve');
                    return null;
                }

                // Create a CatmullRom curve with adjustable tension based on smoothing
                const curve = new THREE.CatmullRomCurve3(points);
                curve.closed = true;

                // Adjust curve type and tension based on smoothing value
                if (this.pathSmoothing < 0.3) {
                    // Low smoothing: use centripetal parameterization for tighter curves
                    curve.curveType = 'centripetal';
                } else if (this.pathSmoothing < 0.7) {
                    // Medium smoothing: use chordal parameterization (default)
                    curve.curveType = 'chordal';
                } else {
                    // High smoothing: use catmullrom parameterization for smoother curves
                    curve.curveType = 'catmullrom';
                }

                return curve;
            }

            setupControls() {
                const preventScroll = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                };

                // Touch controls for mobile
                let touchStart = { x: 0, y: 0 };
                let lastTouch = { x: 0, y: 0 };

                const handleTouchStart = (event) => {
                    if (event.touches.length === 1) {
                        const touch = event.touches[0];
                        touchStart = { x: touch.clientX, y: touch.clientY };
                        lastTouch = { x: touch.clientX, y: touch.clientY };
                    }
                    event.preventDefault();
                };

                const handleTouchMove = (event) => {
                    if (this.isModalOpen) return;

                    if (event.touches.length === 1 && this.isMobile && this.curve) {
                        const touch = event.touches[0];
                        const deltaY = touch.clientY - lastTouch.y;

                        if (Math.abs(deltaY) > 5) {
                            const direction = deltaY > 0 ? 1 : -1;
                            this.velocity += direction * this.acceleration;
                            this.velocity = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.velocity));

                            lastTouch = { x: touch.clientX, y: touch.clientY };
                        }
                    }
                    event.preventDefault();
                };

                // Mouse controls for desktop
                const handleMouseMove = (event) => {
                    if (this.isModalOpen) return;
                    if (!this.isMobile && !this.isPointerLocked) return;

                    const deltaX = event.movementX * 0.002;
                    const deltaY = event.movementY * 0.002;

                    this.yaw -= deltaX;
                    this.pitch -= deltaY;
                    this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));

                    this.updateCameraRotation();
                };

                const handleClick = () => {
                    if (this.isModalOpen) return;
                    if (!this.isMobile && !this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                };

                const handlePointerLockChange = () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                    if (this.renderer.domElement && !this.isMobile) {
                        this.renderer.domElement.style.cursor = this.isPointerLocked ? 'none' : 'crosshair';
                    }
                };

                const handleWheel = (event) => {
                    if (this.isModalOpen) return;
                    if (this.isMobile || !this.curve) return;

                    event.preventDefault();

                    const direction = event.deltaY > 0 ? 1 : -1;
                    this.velocity += direction * this.acceleration * this.scrollingSpeed;
                    this.velocity = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.velocity));
                };

                // Gyroscope handling
                const handleDeviceOrientation = (event) => {
                    if (this.isModalOpen) return;
                    if (!this.isMobile || !this.gyroscopeSupported || this.gyroscopePermission !== 'granted') return;

                    this.gyroscopeData = {
                        alpha: event.alpha || 0,
                        beta: event.beta || 0,
                        gamma: event.gamma || 0
                    };

                    if (this.camera) {
                        const alpha = THREE.MathUtils.degToRad(this.gyroscopeData.alpha);
                        const beta = THREE.MathUtils.degToRad(this.gyroscopeData.beta);
                        const gamma = THREE.MathUtils.degToRad(this.gyroscopeData.gamma);

                        this.camera.rotation.order = 'YXZ';
                        this.camera.rotation.y = alpha;
                        this.camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, beta - Math.PI / 2));
                        this.camera.rotation.z = gamma;
                    }
                };

                // Event listeners
                document.addEventListener('wheel', preventScroll, { passive: false });
                document.addEventListener('touchmove', preventScroll, { passive: false });
                document.addEventListener('scroll', preventScroll, { passive: false });
                document.addEventListener('keydown', (e) => {
                    if ([32, 33, 34, 35, 36, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
                        e.preventDefault();
                    }
                });

                if (this.isMobile) {
                    this.renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                    this.renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });

                    if (this.gyroscopeSupported && this.gyroscopePermission === 'granted') {
                        window.addEventListener('deviceorientation', handleDeviceOrientation);
                    }
                } else {
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('pointerlockchange', handlePointerLockChange);
                    this.renderer.domElement.addEventListener('click', handleClick);
                    this.renderer.domElement.addEventListener('wheel', handleWheel);
                    this.renderer.domElement.style.cursor = 'crosshair';
                }

                // Window resize
                window.addEventListener('resize', () => {
                    if (!this.canvasContainer || !this.camera || !this.renderer) return;
                    this.camera.aspect = this.canvasContainer.clientWidth / this.canvasContainer.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
                });
            }

            updateCameraRotation() {
                // Apply rotation to camera
                this.camera.rotation.y = this.yaw;
                this.camera.rotation.x = this.pitch;
                this.camera.rotation.z = 0; // Prevent roll
            }

            updateBodyPosition() {
                if (!this.curve) return;

                // Update progress with inertia
                this.currentProgress += this.velocity;

                // Loop progress (path is always closed)
                if (this.currentProgress > 1) this.currentProgress -= 1;
                if (this.currentProgress < 0) this.currentProgress += 1;

                // Get position on curve
                const newPosition = this.curve.getPoint(this.currentProgress);
                this.body.position.copy(newPosition);

                // Get direction of movement (tangent to curve)
                const tangent = this.curve.getTangent(this.currentProgress);

                // Orient body along the path
                this.body.lookAt(this.body.position.clone().add(tangent));

                // Apply deceleration (inertia)
                this.velocity *= this.deceleration;

                // Stop movement if velocity becomes very small
                if (Math.abs(this.velocity) < 0.0001) {
                    this.velocity = 0;
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Update body position along path only if we have a valid curve
                if (this.curve) {
                    this.updateBodyPosition();

                    // Auto-play if enabled
                    if (this.isPlaying && !this.isModalOpen) {
                        this.velocity += 0.0005 * this.scrollingSpeed;
                        this.velocity = Math.min(this.maxSpeed, this.velocity);
                    }

                    // Update progress display
                    this.updatePathProgress();
                }

                // Update hint visibility
                this.updateHintVisibility();

                // Render scene
                this.renderer.render(this.scene, this.camera);
            }

            updatePathProgress() {
                const progress = (this.currentProgress % 1) * 100;
                document.getElementById('progress-percent').textContent = Math.round(progress);
                document.getElementById('progress-fill').style.width = progress + '%';
            }

            worldToScreen(worldPosition) {
                if (!this.camera || !this.renderer) return null;

                const vector = worldPosition.clone();
                vector.project(this.camera);

                const x = (vector.x * 0.5 + 0.5) * this.renderer.domElement.clientWidth;
                const y = (vector.y * -0.5 + 0.5) * this.renderer.domElement.clientHeight;

                return { x, y, z: vector.z };
            }

            updateHintVisibility() {
                if (!this.camera || this.hints.length === 0 || this.isModalOpen) return;

                this.hintsOverlay.innerHTML = '';

                this.hints.forEach((hint, index) => {
                    const distance = this.camera.position.distanceTo(hint.position);
                    const isVisible = this.showAllHints || distance < this.hintVisibilityDistance;

                    if (isVisible) {
                        const screenPos = this.worldToScreen(hint.position);

                        if (screenPos && screenPos.z < 1) {
                            const baseSize = this.isMobile ? 40 : 32;
                            const maxSize = this.isMobile ? 80 : 64;
                            const minSize = this.isMobile ? 20 : 16;
                            const scaleFactor = Math.max(0.1, Math.min(1, this.hintVisibilityDistance / distance));
                            const size = Math.max(minSize, Math.min(maxSize, baseSize * scaleFactor));

                            const hintElement = document.createElement('div');
                            hintElement.className = 'absolute pointer-events-auto cursor-pointer transform -translate-x-1-2 -translate-y-1-2';
                            hintElement.style.left = screenPos.x + 'px';
                            hintElement.style.top = screenPos.y + 'px';
                            hintElement.style.width = size + 'px';
                            hintElement.style.height = size + 'px';
                            hintElement.onclick = () => this.showHintModal(hint);

                            hintElement.innerHTML = `
                                <div class="bg-white bg-opacity-90 rounded-full p-2 shadow-lg border-2 border-blue-500 hover-bg-opacity-100 transition-all duration-200">
                                    <span class="icon icon-${hint.icon} text-blue-600" style="display: block; width: 100%; height: 100%;"></span>
                                </div>
                            `;

                            this.hintsOverlay.appendChild(hintElement);
                        }
                    }
                });
            }

            handleMapLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                // Check file extension
                const fileName = file.name.toLowerCase();
                if (!fileName.endsWith('.gltf') && !fileName.endsWith('.glb')) {
                    this.updateMapLoadStatus('Error: Please select a GLTF or GLB file', 'error');
                    return;
                }

                // Create URL for the file
                const fileURL = URL.createObjectURL(file);

                // Update status
                this.updateMapLoadStatus('Loading model...', 'loading');

                // Load the model
                this.gltfLoader.load(
                    fileURL,

                    // onLoad callback
                    (gltf) => {
                        // Remove previous model if exists
                        if (this.currentModel) {
                            this.scene.remove(this.currentModel);
                        }

                        const model = gltf.scene;
                        this.currentModel = model;

                        // Configure the model
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // Calculate model bounding box and center
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());

                        // Calculate the offset needed to center the model
                        this.modelOffset = center.clone().multiplyScalar(-1);

                        // Center the model at origin
                        model.position.copy(this.modelOffset);

                        // Add to scene
                        this.scene.add(model);

                        // Update path with new offset
                        if (this.curve) {
                            this.setPathFromData({ points: this.path });
                        }

                        // Update status
                        this.updateMapLoadStatus(`Model loaded successfully! Size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'success');

                        // Release the object URL
                        URL.revokeObjectURL(fileURL);
                    },

                    // onProgress callback
                    (xhr) => {
                        if (xhr.lengthComputable) {
                            const percentComplete = (xhr.loaded / xhr.total * 100).toFixed(2);
                            this.updateMapLoadStatus(`Loading: ${percentComplete}%`, 'loading');
                        }
                    },

                    // onError callback
                    (error) => {
                        console.error('Error loading model:', error);
                        this.updateMapLoadStatus('Error loading model. Check console for details.', 'error');
                    }
                );
            }

            updateMapLoadStatus(message, type) {
                this.mapLoadStatus.textContent = message;
                this.mapLoadStatus.className = `text-xs p-2 rounded ${type ? 'status-' + type : ''}`;
                this.mapLoadStatus.classList.remove('hidden');
            }

            handlePathLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const pathData = JSON.parse(e.target.result);
                        this.path = pathData.points; // Store original points
                        this.setPathFromData(pathData);
                        alert(`Camera path loaded with ${pathData.points.length} points!`);
                    } catch (error) {
                        alert('Error loading path file.');
                    }
                };
                reader.readAsText(file);
            }

            handleHintLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const hintData = JSON.parse(e.target.result);
                        if (Array.isArray(hintData)) {
                            this.loadHints(hintData);
                            alert(`${hintData.length} hints loaded successfully!`);
                        }
                    } catch (error) {
                        alert('Error loading hint file.');
                    }
                };
                reader.readAsText(file);
            }

            loadHints(hintData) {
                this.hints = [];
                hintData.forEach((hint) => {
                    const position = new THREE.Vector3(
                        hint.position.x,
                        hint.position.y,
                        hint.position.z
                    ).add(this.modelOffset);

                    this.hints.push({
                        position: position,
                        title: hint.title,
                        subtitle: hint.subtitle,
                        text: hint.text,
                        icon: hint.icon || 'map-pin'
                    });
                });
            }

            generateSamplePath() {
                const samplePath = {
                    points: []
                };

                for (let i = 0; i <= 100; i++) {
                    const t = i / 100;
                    const x = Math.cos(t * Math.PI * 4) * 20;
                    const z = Math.sin(t * Math.PI * 4) * 20;
                    const y = 5 + Math.sin(t * Math.PI * 8) * 3;
                    samplePath.points.push({ x, y, z });
                }

                this.path = samplePath.points; // Store original points
                this.setPathFromData(samplePath);
                alert('Sample spiral path generated!');
            }

            generateSampleHints() {
                const sampleHints = [
                    {
                        position: { x: 10, y: 8, z: 10 },
                        title: "Welcome Point",
                        subtitle: "Start of the tour",
                        text: "This is the beginning of your 3D interactive tour. " + (this.isMobile ? "Tilt your device to look around and swipe vertically to navigate." : "Move mouse to look around."),
                        icon: "map-pin"
                    },
                    {
                        position: { x: -15, y: 6, z: 5 },
                        title: "Building Complex",
                        subtitle: "Modern Architecture",
                        text: "These buildings represent modern architectural design with sustainable materials and energy-efficient systems.",
                        icon: "eye"
                    },
                    {
                        position: { x: 0, y: 12, z: -20 },
                        title: "Scenic Viewpoint",
                        subtitle: "Best view in the area",
                        text: "From this position, you can see the entire layout of the virtual environment. Take a moment to appreciate the scale and design.",
                        icon: "map-pin"
                    }
                ];

                this.loadHints(sampleHints);
                alert('Sample hints generated!');
            }

            // UI methods
            togglePlay() {
                if (!this.curve) {
                    alert('Please load a camera path first!');
                    return;
                }

                this.isPlaying = !this.isPlaying;
                const playBtn = document.getElementById('play-btn');
                if (this.isPlaying) {
                    playBtn.innerHTML = '<span class="icon icon-pause"></span><span>Pause</span>';
                    playBtn.className = playBtn.className.replace('button-default', 'button-destructive');
                } else {
                    playBtn.innerHTML = '<span class="icon icon-play"></span><span>Play</span>';
                    playBtn.className = playBtn.className.replace('button-destructive', 'button-default');
                }
            }

            resetCamera() {
                if (!this.curve) return;

                this.currentProgress = 0;
                this.velocity = 0;
                this.updatePathProgress();
                this.isPlaying = false;
                this.togglePlay(); // Update button state
                this.updateBodyPosition();
            }

            toggleShowAllHints() {
                this.showAllHints = !this.showAllHints;
                document.getElementById('toggle-hints-btn').textContent =
                    this.showAllHints ? 'Hide Distant Hints' : 'Show All Hints';
            }

            toggleUICollapse() {
                const content = document.getElementById('panel-content');
                const btn = document.getElementById('collapse-btn');
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    btn.innerHTML = '<span class="icon icon-chevron-up"></span>';
                } else {
                    content.style.display = 'none';
                    btn.innerHTML = '<span class="icon icon-chevron-down"></span>';
                }
            }

            showHintModal(hint) {
                // Pause the game
                this.isModalOpen = true;

                // Set modal content with the hint data
                document.getElementById('hint-modal-title').textContent = hint.title;
                document.getElementById('hint-modal-subtitle').textContent = hint.subtitle || '';
                document.getElementById('hint-modal-text').textContent = hint.text;

                // Show modal
                this.hintModal.style.display = 'flex';
            }

            closeHintModal() {
                // Resume the game
                this.isModalOpen = false;

                // Hide modal
                this.hintModal.style.display = 'none';
            }

            async requestGyroscopePermission() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const permission = await DeviceOrientationEvent.requestPermission();
                        this.gyroscopePermission = permission;
                        if (permission === 'granted') {
                            document.getElementById('gyro-status').textContent = '‚úÖ Gyroscope enabled';
                            document.getElementById('gyro-prompt').classList.add('hidden');
                            alert('Gyroscope enabled! Tilt your device to look around.');
                        } else {
                            alert('Gyroscope permission denied. You can still use touch controls.');
                        }
                    } catch (error) {
                        console.error('Error requesting gyroscope permission:', error);
                        this.gyroscopePermission = 'denied';
                    }
                }
            }

            updateUI() {
                // Show/hide path controls based on whether we have a path
                if (this.curve) {
                    document.getElementById('path-controls').classList.remove('hidden');
                } else {
                    document.getElementById('path-controls').classList.add('hidden');
                }

                // Update smoothing display
                this.updateSmoothingDisplay();
            }
        }

        // Initialize the application when the page loads
        window.addEventListener('DOMContentLoaded', () => {
            new VirtualTour();
        });
    </script>
</body>
</html>
