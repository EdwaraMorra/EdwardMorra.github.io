<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Virtual Tour</title>

    <!-- Three.js Module Import -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
        }

        /* –ü—Ä–∏—Ü–µ–ª */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* UI Components Styles */
        .card {
            background: white;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .card-header {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            line-height: 1;
            letter-spacing: -0.025em;
        }

        .card-content {
            padding: 1.5rem;
            padding-top: 0;
        }

        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            border: none;
            cursor: pointer;
            gap: 0.5rem;
        }

        .button:disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .button-default {
            background: #2563eb;
            color: white;
        }

        .button-default:hover {
            background: #1d4ed8;
        }

        .button-destructive {
            background: #dc2626;
            color: white;
        }

        .button-destructive:hover {
            background: #b91c1c;
        }

        .button-outline {
            background: transparent;
            border: 1px solid #d1d5db;
            color: inherit;
        }

        .button-outline:hover {
            background: #f9fafb;
        }

        .button-ghost {
            background: transparent;
            color: inherit;
            border: none;
        }

        .button-ghost:hover {
            background: #f9fafb;
        }

        .button-sm {
            height: 2.25rem;
            padding: 0 0.75rem;
            font-size: 0.875rem;
        }

        .button-default-size {
            height: 2.5rem;
            padding: 0 1rem;
        }

        .space-y-2 > * + * {
            margin-top: 0.5rem;
        }

        .space-y-3 > * + * {
            margin-top: 0.75rem;
        }

        .space-x-2 > * + * {
            margin-left: 0.5rem;
        }

        .flex {
            display: flex;
        }

        .items-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .w-full {
            width: 100%;
        }

        .w-80 {
            width: 20rem;
        }

        .h-8 {
            height: 2rem;
        }

        .h-9 {
            height: 2.25rem;
        }

        .h-10 {
            height: 2.5rem;
        }

        .w-8 {
            width: 2rem;
        }

        .p-0 {
            padding: 0;
        }

        .p-2 {
            padding: 0.5rem;
        }

        .p-4 {
            padding: 1rem;
        }

        .text-sm {
            font-size: 0.875rem;
        }

        .text-xs {
            font-size: 0.75rem;
        }

        .text-lg {
            font-size: 1.125rem;
        }

        .text-xl {
            font-size: 1.25rem;
        }

        .font-medium {
            font-weight: 500;
        }

        .font-semibold {
            font-weight: 600;
        }

        .text-gray-600 {
            color: #4b5563;
        }

        .text-gray-800 {
            color: #1f2937;
        }

        .text-blue-600 {
            color: #2563eb;
        }

        .text-blue-800 {
            color: #1e40af;
        }

        .bg-white {
            background: white;
        }

        .bg-blue-50 {
            background: #eff6ff;
        }

        .bg-blue-100 {
            background: #dbeafe;
        }

        .bg-gray-200 {
            background: #e5e7eb;
        }

        .bg-blue-600 {
            background: #2563eb;
        }

        .bg-black {
            background: black;
        }

        .bg-opacity-50 {
            opacity: 0.5;
        }

        .bg-opacity-90 {
            opacity: 0.9;
        }

        .rounded {
            border-radius: 0.25rem;
        }

        .rounded-full {
            border-radius: 9999px;
        }

        .rounded-lg {
            border-radius: 0.5rem;
        }

        .border {
            border: 1px solid #e5e7eb;
        }

        .border-2 {
            border-width: 2px;
        }

        .border-blue-200 {
            border-color: #bfdbfe;
        }

        .border-blue-500 {
            border-color: #3b82f6;
        }

        .shadow-lg {
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }

        .absolute {
            position: absolute;
        }

        .relative {
            position: relative;
        }

        .inset-0 {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        .top-4 {
            top: 1rem;
        }

        .left-4 {
            left: 1rem;
        }

        .z-10 {
            z-index: 10;
        }

        .z-20 {
            z-index: 20;
        }

        .z-30 {
            z-index: 30;
        }

        .z-40 {
            z-index: 40;
        }

        .pointer-events-none {
            pointer-events: none;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        .cursor-pointer {
            cursor: pointer;
        }

        .transform {
            transform: translate(var(--tw-translate-x), var(--tw-translate-y));
        }

        .-translate-x-1-2 {
            transform: translateX(-50%);
        }

        .-translate-y-1-2 {
            transform: translateY(-50%);
        }

        .transition-all {
            transition: all 0.2s;
        }

        .duration-200 {
            transition-duration: 200ms;
        }

        .duration-300 {
            transition-duration: 300ms;
        }

        .hidden {
            display: none;
        }

        .block {
            display: block;
        }

        .flex-1 {
            flex: 1;
        }

        .max-w-90vw {
            max-width: 90vw;
        }

        .max-w-sm {
            max-width: 24rem;
        }

        .h-2 {
            height: 0.5rem;
        }

        .h-screen {
            height: 100vh;
        }

        .touch-none {
            touch-action: none;
        }

        .overflow-hidden {
            overflow: hidden;
        }

        .leading-relaxed {
            line-height: 1.625;
        }

        .mt-1 {
            margin-top: 0.25rem;
        }

        .mb-4 {
            margin-bottom: 1rem;
        }

        .hover-bg-opacity-100:hover {
            opacity: 1;
        }

        input[type="range"] {
            width: 100%;
            height: 0.375rem;
            border-radius: 0.25rem;
            background: #d1d5db;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
        }

        .progress-bar {
            width: 100%;
            background: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #2563eb;
            transition: width 0.2s;
        }

        .status-loading {
            background: rgba(255, 193, 7, 0.2);
            color: #ffa000;
            border-left: 4px solid #ffc107;
        }

        .status-success {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border-left: 4px solid #4caf50;
        }

        .status-error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border-left: 4px solid #f44336;
        }

        /* Simple icon styles */
        .icon {
            width: 1rem;
            height: 1rem;
            display: inline-block;
        }

        .icon-upload::before {
            content: 'üì§';
        }

        .icon-rotate-ccw::before {
            content: 'üîÑ';
        }

        .icon-play::before {
            content: '‚ñ∂Ô∏è';
        }

        .icon-pause::before {
            content: '‚è∏Ô∏è';
        }

        .icon-eye::before {
            content: 'üëÅÔ∏è';
        }

        .icon-x::before {
            content: '‚ùå';
        }

        .icon-map-pin::before {
            content: 'üìç';
        }

        .icon-chevron-up::before {
            content: '‚Üë';
        }

        .icon-chevron-down::before {
            content: '‚Üì';
        }

        /* Hint Modal Styles */
        #hint-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(4px);
        }

        .hint-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            padding: 0;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            overflow: hidden;
        }

        .hint-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }

        .hint-modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #1f2937;
            flex: 1;
        }

        .hint-modal-subtitle {
            font-size: 1rem;
            color: #6b7280;
        }

        .hint-modal-body {
            padding: 1.5rem;
            line-height: 1.6;
            color: #374151;
        }

        .hint-modal-footer {
            padding: 1rem 1.5rem 1.5rem;
            display: flex;
            justify-content: flex-end;
        }

        .hint-modal-close-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .hint-modal-close-btn:hover {
            background: #1d4ed8;
        }

        /* Close button in header */
        .modal-close-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            color: #6b7280;
            transition: color 0.2s;
            margin-left: 1rem;
        }

        .modal-close-button:hover {
            color: #374151;
        }

        /* Hint icon styles - –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: —É–±—Ä–∞–Ω–∞ –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è */
        .hint-icon {
        position: absolute;
        width: 52px;
        height: 52px;
        background: #ffffff;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        pointer-events: auto;
        z-index: 10;
        transform: translate(-50%, -50%);
        transition: none !important;
        }

        .hint-icon:hover {
            transform: translate(-50%, -50%) scale(1.2);
            background: #1d4ed8;
            /* –û—Å—Ç–∞–≤–ª—è–µ–º transition —Ç–æ–ª—å–∫–æ –¥–ª—è hover —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ */
            transition: transform 0.3s ease, background 0.3s ease;
        }

        .hint-icon::before {
            content: 'üí°';
            font-size: 16px;
        }

        /* Shot effect */
        .shot-effect {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%);
            pointer-events: none;
            z-index: 1001;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .shot-effect.active {
            opacity: 1;
            animation: shotPulse 0.3s ease-out;
        }

        @keyframes shotPulse {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(2);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <!-- –ü—Ä–∏—Ü–µ–ª -->
    <div class="crosshair"></div>
    <!-- –≠—Ñ—Ñ–µ–∫—Ç –≤—ã—Å—Ç—Ä–µ–ª–∞ -->
    <div id="shot-effect" class="shot-effect"></div>
    <!-- 2D Hint Icons Overlay -->
    <div id="hints-overlay" class="absolute inset-0 pointer-events-none z-30"></div>

    <!-- Control Panel -->
    <div id="control-panel" class="absolute top-4 left-4 z-20 transition-all duration-300 w-80 max-w-90vw">
        <div class="card relative">
            <div class="card-header pb-2">
                <div class="flex items-center justify-between">
                    <h3 class="card-title text-lg" id="panel-title">3D Tour Controls</h3>
                    <button id="collapse-btn" class="button button-ghost h-8 w-8 p-0">
                        <span class="icon icon-chevron-up"></span>
                    </button>
                </div>
            </div>

            <div id="panel-content" class="card-content space-y-3">
                <!-- Mobile gyroscope permission -->
                <div id="gyro-prompt" class="space-y-2 hidden">
                    <button id="enable-gyro-btn" class="button button-outline w-full text-sm">
                        üéØ Enable Gyroscope Control
                    </button>
                </div>

                <!-- Mobile status indicator -->
                <div id="mobile-status" class="text-xs bg-blue-50 p-2 rounded border border-blue-200 hidden">
                    <p class="font-medium text-blue-800">üì± Mobile Mode Active</p>
                    <p id="gyro-status" class="text-blue-600">‚ö†Ô∏è Gyroscope disabled</p>
                </div>

                <!-- Map loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Load Map/Environment:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json,.glb,.gltf" id="map-upload" class="hidden">
                        <button id="load-map-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-upload"></span>
                            <span>Load Map</span>
                        </button>
                    </div>
                    <!-- Status for GLTF loading -->
                    <div id="map-load-status" class="text-xs p-2 rounded hidden"></div>
                </div>

                <!-- Path loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Camera Path:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json" id="path-upload" class="hidden">
                        <button id="load-path-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-upload"></span>
                            <span>Load Path</span>
                        </button>
                        <button id="sample-path-btn" class="button button-outline button-sm text-xs">
                            Sample Path
                        </button>
                    </div>
                </div>

                <!-- Hints loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Hints:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json" id="hint-upload" class="hidden">
                        <button id="load-hints-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-map-pin"></span>
                            <span>Load Hints</span>
                        </button>
                        <button id="sample-hints-btn" class="button button-outline button-sm text-xs">
                            Sample Hints
                        </button>
                    </div>
                </div>

                <!-- Hint settings -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Hint Settings:</label>
                    <div class="space-y-2">
                        <button id="toggle-hints-btn" class="button button-outline button-sm w-full text-xs">
                            Show All Hints
                        </button>
                        <div class="flex items-center space-x-2">
                            <label class="text-xs">Distance:</label>
                            <input type="range" min="5" max="50" value="15" id="hint-distance-slider" class="flex-1">
                            <span id="hint-distance-value" class="text-xs w-8">15</span>
                        </div>
                    </div>
                </div>

                <!-- Path controls -->
                <div id="path-controls" class="space-y-2 hidden">
                    <label class="block text-sm font-medium">Path Progress: <span id="progress-percent">0</span>%</label>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
                    </div>

                    <div class="space-y-2">
                        <label class="block text-sm font-medium">Scrolling Speed:</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs w-8">0.1x</span>
                            <input type="range" min="0.1" max="3.0" step="0.1" value="1.0" id="speed-slider" class="flex-1">
                            <span class="text-xs w-8">3.0x</span>
                        </div>
                        <div class="text-center">
                            <span id="speed-display" class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">1.0x speed</span>
                        </div>
                    </div>

                    <!-- Path Smoothing Control -->
                    <div class="space-y-2">
                        <label class="block text-sm font-medium">Path Smoothing:</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs w-8">Low</span>
                            <input type="range" min="0.0" max="1.0" step="0.1" value="0.5" id="smoothing-slider" class="flex-1">
                            <span class="text-xs w-8">High</span>
                        </div>
                        <div class="text-center">
                            <span id="smoothing-display" class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">Medium smoothing</span>
                        </div>
                    </div>

                    <div class="flex space-x-2">
                        <button id="play-btn" class="button button-default button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-play"></span>
                            <span>Play</span>
                        </button>
                        <button id="reset-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-rotate-ccw"></span>
                            <span>Reset</span>
                        </button>
                    </div>
                </div>

                <!-- Instructions -->
                <div class="text-xs text-gray-600 space-y-1">
                    <p><strong>üñ±Ô∏è Mouse:</strong> Move to look around (click to lock pointer)</p>
                    <p><strong>üé° Mouse Wheel:</strong> Navigate along path (infinite loop)</p>
                    <p><strong>üí° Hints:</strong> Click 2D icons or aim at invisible spheres and click to view information</p>
                    <p><strong>üö´ No Page Scroll:</strong> All scrolling disabled</p>
                    <p><strong>‚ö° Speed Control:</strong> Adjust scrolling speed (0.1x - 3.0x)</p>
                    <p><strong>üîÑ Path Smoothing:</strong> Control how smooth the path is between points</p>
                    <p><strong>üó∫Ô∏è Map Format:</strong> GLB, GLTF files supported</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Hint Modal -->
    <div id="hint-modal">
        <div class="hint-modal-content">
            <div class="hint-modal-header">
                <div>
                    <h2 id="hint-modal-title" class="hint-modal-title">Hint Title</h2>
                    <p id="hint-modal-subtitle" class="hint-modal-subtitle">Hint Subtitle</p>
                </div>
                <button id="modal-close-button" class="modal-close-button" title="Close">
                    √ó
                </button>
            </div>
            <div class="hint-modal-body">
                <p id="hint-modal-text">Hint text content will appear here when you click on a hint icon.</p>
            </div>
            <div class="hint-modal-footer">
                <button id="hint-modal-close-btn" class="hint-modal-close-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 z-40">
        <div class="text-white text-xl">Loading 3D Scene...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Main application
        class VirtualTour {
            constructor() {
                this.scene = null;
                this.renderer = null;
                this.camera = null;
                this.gltfLoader = null;

                // Camera system
                this.body = null;
                this.path = [];
                this.curve = null;
                this.currentProgress = 0;
                this.velocity = 0;
                this.isPlaying = false;

                // Camera rotation
                this.pitch = 0;
                this.yaw = 0;
                this.isPointerLocked = false;

                this.hints = [];
                this.hintSpheres = [];
                this.visibleHints = [];

                // Current model
                this.currentModel = null;
                this.modelOffset = new THREE.Vector3(0, 0, 0);

                // Mobile-specific
                this.isMobile = false;
                this.gyroscopeSupported = false;
                this.gyroscopePermission = 'prompt';
                this.gyroscopeData = { alpha: 0, beta: 0, gamma: 0 };

                // Settings
                this.scrollingSpeed = 1.0;
                this.showAllHints = false;
                this.hintVisibilityDistance = 15;
                this.pathSmoothing = 0.5;

                // Modal and pause state
                this.isModalOpen = false;
                this.isPaused = false;

                // DOM elements
                this.canvasContainer = document.getElementById('canvas-container');
                this.hintsOverlay = document.getElementById('hints-overlay');
                this.controlPanel = document.getElementById('control-panel');
                this.mapLoadStatus = document.getElementById('map-load-status');
                this.hintModal = document.getElementById('hint-modal');
                this.shotEffect = document.getElementById('shot-effect');
                this.modalCloseButton = document.getElementById('modal-close-button');

                // Raycaster for hints
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                // Inertia parameters
                this.acceleration = 0.0005;
                this.deceleration = 0.95;
                this.maxSpeed = 0.02;

                // Control state
                this.isControlCaptured = false;
                this.previousMousePosition = { x: 0, y: 0 };

                this.init();
            }

            init() {
                this.detectMobile();
                this.setupEventListeners();
                this.initThreeJS();
                this.loadDefaultMap();
                this.updateUI();
            }

            detectMobile() {
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                              (window.innerWidth <= 768);

                if (this.isMobile && 'DeviceOrientationEvent' in window) {
                    this.gyroscopeSupported = true;
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        this.gyroscopePermission = 'prompt';
                    } else {
                        this.gyroscopePermission = 'granted';
                    }
                }

                // Update UI for mobile
                if (this.isMobile) {
                    document.getElementById('panel-title').textContent += ' üì±';
                    document.getElementById('gyro-prompt').classList.remove('hidden');
                    document.getElementById('mobile-status').classList.remove('hidden');

                    // Update instructions for mobile
                    const instructions = document.querySelector('.text-xs.text-gray-600');
                    instructions.innerHTML = `
                        <p><strong>üì± Gyroscope:</strong> Tilt device to look around</p>
                        <p><strong>üëÜ Touch Scroll:</strong> Swipe vertically to navigate path</p>
                        <p><strong>üí° Hints:</strong> Tap 2D icons or aim at invisible spheres and tap to view information</p>
                        <p><strong>üö´ No Page Scroll:</strong> All scrolling disabled</p>
                        <p><strong>‚ö° Speed Control:</strong> Adjust scrolling speed (0.1x - 3.0x)</p>
                        <p><strong>üîÑ Path Smoothing:</strong> Control how smooth the path is between points</p>
                        <p><strong>üó∫Ô∏è Map Format:</strong> GLB, GLTF files supported</p>
                    `;
                }
            }

            setupEventListeners() {
                // File uploads
                document.getElementById('load-map-btn').addEventListener('click', () => {
                    document.getElementById('map-upload').click();
                });
                document.getElementById('load-path-btn').addEventListener('click', () => {
                    document.getElementById('path-upload').click();
                });
                document.getElementById('load-hints-btn').addEventListener('click', () => {
                    document.getElementById('hint-upload').click();
                });

                document.getElementById('map-upload').addEventListener('change', (e) => this.handleMapLoad(e));
                document.getElementById('path-upload').addEventListener('change', (e) => this.handlePathLoad(e));
                document.getElementById('hint-upload').addEventListener('change', (e) => this.handleHintLoad(e));

                // Buttons
                document.getElementById('sample-path-btn').addEventListener('click', () => this.generateSamplePath());
                document.getElementById('sample-hints-btn').addEventListener('click', () => this.generateSampleHints());
                document.getElementById('enable-gyro-btn').addEventListener('click', () => this.requestGyroscopePermission());
                document.getElementById('toggle-hints-btn').addEventListener('click', () => this.toggleShowAllHints());
                document.getElementById('play-btn').addEventListener('click', () => this.togglePlay());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetCamera());
                document.getElementById('collapse-btn').addEventListener('click', () => this.toggleUICollapse());
                document.getElementById('hint-modal-close-btn').addEventListener('click', () => this.closeHintModal());
                this.modalCloseButton.addEventListener('click', () => this.closeHintModal());

                // Sliders
                document.getElementById('hint-distance-slider').addEventListener('input', (e) => {
                    this.hintVisibilityDistance = parseInt(e.target.value);
                    document.getElementById('hint-distance-value').textContent = this.hintVisibilityDistance;
                    this.updateHintVisibility();
                });

                document.getElementById('speed-slider').addEventListener('input', (e) => {
                    this.scrollingSpeed = parseFloat(e.target.value);
                    document.getElementById('speed-display').textContent = this.scrollingSpeed + 'x speed';
                });

                // Path smoothing slider
                document.getElementById('smoothing-slider').addEventListener('input', (e) => {
                    this.pathSmoothing = parseFloat(e.target.value);
                    this.updateSmoothingDisplay();
                    // Update path with new smoothing
                    if (this.path.length > 0) {
                        this.setPathFromData({ points: this.path });
                    }
                });

                // Mouse events for FPS control
                document.addEventListener('mousedown', (event) => {
                    if (this.isPaused) return;
                    
                    if (event.button === 0) { // –õ–ö–ú
                        if (!this.isControlCaptured && !this.isMobile) {
                            // –ó–∞—Ö–≤–∞—Ç—ã–≤–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∫–ª–∏–∫–µ
                            this.captureControl();
                            this.previousMousePosition = { x: event.clientX, y: event.clientY };
                        } else {
                            // –ï—Å–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É–∂–µ –∑–∞—Ö–≤–∞—á–µ–Ω–æ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–ø–∞–¥–∞–Ω–∏–µ –≤ –∏–∫–æ–Ω–∫—É
                            const hitHint = this.checkIconHit();
                            if (hitHint) {
                                // –≠—Ñ—Ñ–µ–∫—Ç –≤—ã—Å—Ç—Ä–µ–ª–∞
                                this.shotEffect.classList.remove('active');
                                void this.shotEffect.offsetWidth; // Trigger reflow
                                this.shotEffect.classList.add('active');
                                
                                // –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É
                                setTimeout(() => {
                                    this.showHintModal(hitHint);
                                }, 100);
                            }
                        }
                    }
                });

                // Touch events for mobile
                if (this.isMobile) {
                    document.addEventListener('touchstart', (event) => {
                        if (this.isPaused) return;
                        
                        if (event.touches.length === 1) {
                            const hitHint = this.checkIconHit();
                            if (hitHint) {
                                // –≠—Ñ—Ñ–µ–∫—Ç –≤—ã—Å—Ç—Ä–µ–ª–∞
                                this.shotEffect.classList.remove('active');
                                void this.shotEffect.offsetWidth;
                                this.shotEffect.classList.add('active');
                                
                                // –û—Ç–∫—Ä—ã–≤–∞–µ–º –ø–æ–¥—Å–∫–∞–∑–∫—É
                                setTimeout(() => {
                                    this.showHintModal(hitHint);
                                }, 100);
                            }
                        }
                    }, { passive: true });
                }
            }

            checkIconHit() {
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const hitRadius = 50; // –£–º–µ–Ω—å—à–∏–ª —Ä–∞–¥–∏—É—Å –ø–æ–ø–∞–¥–∞–Ω–∏—è –¥–æ 50 –ø–∏–∫—Å–µ–ª–µ–π
                
                const hintIcons = this.hintsOverlay.querySelectorAll('.hint-icon');
                for (let icon of hintIcons) {
                    if (icon.style.display === 'none') continue;
                    
                    const rect = icon.getBoundingClientRect();
                    const iconX = rect.left + rect.width / 2;
                    const iconY = rect.top + rect.height / 2;
                    
                    const distance = Math.sqrt(
                        Math.pow(iconX - centerX, 2) + Math.pow(iconY - centerY, 2)
                    );
                    
                    if (distance < hitRadius) {
                        const hintIndex = parseInt(icon.dataset.hintIndex);
                        return this.visibleHints[hintIndex];
                    }
                }
                return null;
            }

            captureControl() {
                if (!this.isMobile) {
                    this.renderer.domElement.requestPointerLock();
                    this.isControlCaptured = true;
                }
            }

            updateSmoothingDisplay() {
                let smoothingText;
                if (this.pathSmoothing < 0.3) {
                    smoothingText = "Low smoothing";
                } else if (this.pathSmoothing < 0.7) {
                    smoothingText = "Medium smoothing";
                } else {
                    smoothingText = "High smoothing";
                }
                document.getElementById('smoothing-display').textContent = smoothingText;
            }

            initThreeJS() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);

                // Create body that moves along the path
                this.body = new THREE.Object3D();
                this.scene.add(this.body);

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    this.canvasContainer.clientWidth / this.canvasContainer.clientHeight,
                    0.1,
                    1000
                );
                this.body.add(this.camera);
                this.camera.position.set(0, 0, 0);

                // Set camera rotation order to prevent roll
                this.camera.rotation.order = 'YXZ';

                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
                this.canvasContainer.appendChild(this.renderer.domElement);

                // GLTF Loader
                this.gltfLoader = new GLTFLoader();

                // Setup controls
                this.setupControls();

                // Start animation loop
                this.animate();

                // Hide loading overlay
                document.getElementById('loading-overlay').classList.add('hidden');
            }

            loadDefaultMap() {
                // Load default map from map.glb
                this.updateMapLoadStatus('Loading default map...', 'loading');

                this.gltfLoader.load(
                    'map.glb',

                    // onLoad callback
                    (gltf) => {
                        // Remove previous model if exists
                        if (this.currentModel) {
                            this.scene.remove(this.currentModel);
                        }

                        const model = gltf.scene;
                        this.currentModel = model;

                        // Configure the model
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // Calculate model bounding box and center
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());

                        // Calculate the offset needed to center the model
                        this.modelOffset = center.clone().multiplyScalar(-1);

                        // Center the model at origin
                        model.position.copy(this.modelOffset);

                        // Add to scene
                        this.scene.add(model);

                        // Load default path after map is loaded
                        this.loadDefaultPath();

                        // Update status
                        this.updateMapLoadStatus(`Default map loaded successfully! Size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'success');
                    },

                    // onProgress callback
                    (xhr) => {
                        if (xhr.lengthComputable) {
                            const percentComplete = (xhr.loaded / xhr.total * 100).toFixed(2);
                            this.updateMapLoadStatus(`Loading default map: ${percentComplete}%`, 'loading');
                        }
                    },

                    // onError callback
                    (error) => {
                        console.error('Error loading default map:', error);
                        this.updateMapLoadStatus('Default map not found. You can load a map manually.', 'error');
                        // Load default path even if map fails
                        this.loadDefaultPath();
                    }
                );
            }

            loadDefaultPath() {
                // Load default path from path.json
                fetch('path.json')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Path file not found');
                        }
                        return response.json();
                    })
                    .then(data => {
                        this.setPathFromData(data);
                    })
                    .catch(error => {
                        console.error('Error loading default path:', error);
                        // Generate sample path if default path not found
                        this.generateSamplePath();
                    });
            }

            setPathFromData(pathData) {
                // Clear existing path visualization
                if (this.pathLine) {
                    this.scene.remove(this.pathLine);
                }

                // Convert points to Vector3 with high precision
                const points = pathData.points.map(p => {
                    return new THREE.Vector3(
                        parseFloat(p.x.toFixed(15)),
                        parseFloat(p.y.toFixed(15)),
                        parseFloat(p.z.toFixed(15))
                    );
                });

                // Apply model offset to align path with model
                const adjustedPoints = points.map(point =>
                    point.clone().add(this.modelOffset)
                );

                // Create curve from points with adjustable smoothing
                this.curve = this.createSmoothCurve(adjustedPoints);

                // Check if curve was created successfully
                if (!this.curve) {
                    console.error('Failed to create path curve');
                    return;
                }

                // Create visualization
                const pathGeometry = new THREE.BufferGeometry().setFromPoints(this.curve.getPoints(500));
                const pathMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                this.pathLine = new THREE.Line(pathGeometry, pathMaterial);
                // this.scene.add(this.pathLine);

                // Set initial position
                if (points.length > 0) {
                    const initialPoint = this.curve.getPoint(0);
                    this.body.position.copy(initialPoint);

                    // Look along the path
                    const lookAtPoint = this.curve.getPoint(0.01);
                    this.body.lookAt(lookAtPoint);
                }

                this.updateUI();
            }

            createSmoothCurve(points) {
                // Check if we have enough points
                if (points.length < 2) {
                    console.warn('Not enough points to create curve');
                    return null;
                }

                // Create a CatmullRom curve with adjustable tension based on smoothing
                const curve = new THREE.CatmullRomCurve3(points);
                curve.curveType = 'centripetal'; // 'centripetal', 'chordal', 'catmullrom'

                // Adjust tension based on smoothing value (0.0 - 1.0)
                // Lower smoothing = more direct path, higher smoothing = smoother path
                curve.tension = this.pathSmoothing;

                return curve;
            }

            setupControls() {
                // Pointer lock for desktop
                this.renderer.domElement.addEventListener('click', () => {
                    if (this.isPaused) return;
                    
                    if (!this.isPointerLocked && !this.isMobile) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                // Pointer lock change event
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                    this.isControlCaptured = this.isPointerLocked;
                    
                    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –∫—É—Ä—Å–æ—Ä –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è pointer lock
                    if (this.isPointerLocked) {
                        document.body.style.cursor = 'none';
                    } else {
                        document.body.style.cursor = 'auto';
                    }
                });

                // Mouse movement for camera rotation
                document.addEventListener('mousemove', (event) => {
                    if (this.isPaused) return;
                    
                    if (this.isPointerLocked && !this.isMobile) {
                        const movementX = event.movementX || 0;
                        const movementY = event.movementY || 0;

                        this.yaw -= movementX * 0.002;
                        this.pitch -= movementY * 0.002;

                        // Clamp pitch to prevent flipping
                        this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
                    }
                });

                // Mouse wheel for path navigation
                document.addEventListener('wheel', (event) => {
                    if (this.isPaused) return;
                    
                    event.preventDefault();

                    // Calculate velocity based on wheel delta and speed setting
                    const delta = -Math.sign(event.deltaY) * 0.0005 * this.scrollingSpeed;
                    this.velocity += delta;

                    // Clamp velocity to max speed
                    this.velocity = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.velocity));
                }, { passive: false });

                // Touch events for mobile path navigation
                if (this.isMobile) {
                    let touchStartY = 0;
                    let isScrolling = false;

                    document.addEventListener('touchstart', (event) => {
                        if (this.isPaused) return;
                        
                        if (event.touches.length === 1) {
                            touchStartY = event.touches[0].clientY;
                            isScrolling = true;
                        }
                    }, { passive: true });

                    document.addEventListener('touchmove', (event) => {
                        if (this.isPaused) return;
                        
                        if (isScrolling && event.touches.length === 1) {
                            const touchY = event.touches[0].clientY;
                            const deltaY = touchStartY - touchY;

                            // Apply velocity based on touch movement
                            this.velocity = deltaY * 0.0001 * this.scrollingSpeed;

                            touchStartY = touchY;
                        }
                    }, { passive: true });

                    document.addEventListener('touchend', () => {
                        isScrolling = false;
                    }, { passive: true });
                }

                // Prevent default scroll behavior
                document.addEventListener('scroll', (e) => e.preventDefault());
                document.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
                document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }

            updateCameraRotation() {
                if (this.isPaused) return;
                
                if (this.isMobile && this.gyroscopePermission === 'granted') {
                    // Use gyroscope data for mobile
                    const { alpha, beta, gamma } = this.gyroscopeData;

                    // Convert device orientation to camera rotation
                    this.yaw = -alpha * (Math.PI / 180); // Convert degrees to radians
                    this.pitch = beta * (Math.PI / 180) - Math.PI / 2; // Adjust pitch range

                    // Clamp pitch
                    this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
                }

                // Apply rotation to camera
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.yaw;
                this.camera.rotation.x = this.pitch;
                this.camera.rotation.z = 0; // Prevent roll
            }

            handleMapLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.updateMapLoadStatus(`Loading ${file.name}...`, 'loading');

                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;

                    this.gltfLoader.parse(
                        arrayBuffer,
                        '',
                        (gltf) => {
                            // Remove previous model if exists
                            if (this.currentModel) {
                                this.scene.remove(this.currentModel);
                            }

                            const model = gltf.scene;
                            this.currentModel = model;

                            // Configure the model
                            model.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });

                            // Calculate model bounding box and center
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());

                            // Calculate the offset needed to center the model
                            this.modelOffset = center.clone().multiplyScalar(-1);

                            // Center the model at origin
                            model.position.copy(this.modelOffset);

                            // Add to scene
                            this.scene.add(model);

                            this.updateMapLoadStatus(`${file.name} loaded successfully! Size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'success');

                            // Reset path and camera when new map is loaded
                            this.path = [];
                            this.curve = null;
                            this.currentProgress = 0;
                            this.velocity = 0;
                            this.isPlaying = false;
                            this.updateUI();
                        },
                        (error) => {
                            console.error('Error loading GLTF:', error);
                            this.updateMapLoadStatus(`Error loading ${file.name}: ${error.message}`, 'error');
                        }
                    );
                };

                reader.readAsArrayBuffer(file);
                event.target.value = ''; // Reset file input
            }

            handlePathLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const pathData = JSON.parse(e.target.result);
                        this.setPathFromData(pathData);
                    } catch (error) {
                        console.error('Error parsing path file:', error);
                        alert('Error loading path file: ' + error.message);
                    }
                };

                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            }

            handleHintLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const hintData = JSON.parse(e.target.result);
                        this.setHintsFromData(hintData);
                    } catch (error) {
                        console.error('Error parsing hint file:', error);
                        alert('Error loading hint file: ' + error.message);
                    }
                };

                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            }

            setHintsFromData(hintData) {
                // Clear existing hints
                this.hintSpheres.forEach(hint => {
                    this.scene.remove(hint.sphere);
                });
                this.hints = [];
                this.hintSpheres = [];

                // Add new hints
                hintData.hints.forEach((hint, index) => {
                    this.addHint(hint, index);
                });

                this.updateHintVisibility();
            }

            addHint(hintData, index) {
                // Create invisible sphere for 3D interaction
                const sphereGeometry = new THREE.SphereGeometry(hintData.sphereRadius || 2, 8, 6);
                const sphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    transparent: true,
                    opacity: 0.0 // Completely invisible
                });

                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(
                    hintData.position.x + this.modelOffset.x,
                    hintData.position.y + this.modelOffset.y,
                    hintData.position.z + this.modelOffset.z
                );

                // Store hint data
                sphere.userData = {
                    isHint: true,
                    hintIndex: index,
                    title: hintData.title,
                    subtitle: hintData.subtitle,
                    text: hintData.text
                };

                this.scene.add(sphere);
                this.hints.push(hintData);
                this.hintSpheres.push({
                    data: hintData,
                    sphere: sphere
                });
            }

            showHintModal(hintData) {
                document.getElementById('hint-modal-title').textContent = hintData.title;
                document.getElementById('hint-modal-subtitle').textContent = hintData.subtitle;
                document.getElementById('hint-modal-text').textContent = hintData.text;
                this.hintModal.style.display = 'flex';
                this.isModalOpen = true;
                this.isPaused = true; // –°—Ç–∞–≤–∏–º –∏–≥—Ä—É –Ω–∞ –ø–∞—É–∑—É
                
                // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–≤–∏–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã
                this.velocity = 0;
                if (this.isPlaying) {
                    this.togglePlay(); // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–≤—Ç–æ–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ
                }
                
                // –í—ã—Ö–æ–¥–∏–º –∏–∑ —Ä–µ–∂–∏–º–∞ pointer lock –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫—É—Ä—Å–æ—Ä
                if (this.isPointerLocked) {
                    document.exitPointerLock();
                }
                document.body.style.cursor = 'auto'; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫—É—Ä—Å–æ—Ä
            }

            closeHintModal() {
                this.hintModal.style.display = 'none';
                this.isModalOpen = false;
                this.isPaused = false; // –°–Ω–∏–º–∞–µ–º –∏–≥—Ä—É —Å –ø–∞—É–∑—ã
                
                // –ï—Å–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±—ã–ª–æ –∑–∞—Ö–≤–∞—á–µ–Ω–æ, —Å–∫—Ä—ã–≤–∞–µ–º –∫—É—Ä—Å–æ—Ä
                if (this.isControlCaptured && !this.isMobile) {
                    document.body.style.cursor = 'none';
                }
            }

            updateHintPositions() {
                // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –º–∏—Ä–æ–≤—ã–µ –º–∞—Ç—Ä–∏—Ü—ã –∫–∞–º–µ—Ä—ã
                this.camera.updateMatrixWorld(true);
                this.camera.updateProjectionMatrix();
                
                const hintElements = this.hintsOverlay.querySelectorAll('.hint-icon');
                const cameraWorldPosition = new THREE.Vector3();
                this.camera.getWorldPosition(cameraWorldPosition);
                
                hintElements.forEach(element => {
                    const hintIndex = parseInt(element.dataset.hintIndex);
                    const hint = this.visibleHints[hintIndex];

                    if (hint) {
                        const hintPosition = new THREE.Vector3(
                            hint.position.x + this.modelOffset.x,
                            hint.position.y + this.modelOffset.y,
                            hint.position.z + this.modelOffset.z
                        );

                        // Convert 3D position to 2D screen position
                        const screenPosition = hintPosition.clone();
                        
                        // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—É—â—É—é –º–∞—Ç—Ä–∏—Ü—É –ø—Ä–æ–µ–∫—Ü–∏–∏ –∫–∞–º–µ—Ä—ã
                        screenPosition.project(this.camera);

                        // Check if hint is in front of camera
                        if (screenPosition.z > 0 && screenPosition.z < 1) {
                            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;

                            // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–µ–∑ –∞–Ω–∏–º–∞—Ü–∏–∏
                            element.style.transition = 'none';
                            element.style.left = x + 'px';
                            element.style.top = y + 'px';
                            element.style.display = 'flex';
                            
                            // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π reflow
                            void element.offsetWidth;
                        } else {
                            element.style.display = 'none';
                        }
                    }
                });
            }

            updateHintVisibility() {
                // Clear existing 2D hints
                this.hintsOverlay.innerHTML = '';

                // Filter visible hints based on distance
                this.visibleHints = this.hints.filter((hint, index) => {
                    if (this.showAllHints) return true;

                    const hintPosition = new THREE.Vector3(
                        hint.position.x + this.modelOffset.x,
                        hint.position.y + this.modelOffset.y,
                        hint.position.z + this.modelOffset.z
                    );

                    const distance = this.body.position.distanceTo(hintPosition);
                    return distance <= this.hintVisibilityDistance;
                });

                // Update 3D sphere visibility
                this.hintSpheres.forEach((hintObj, index) => {
                    const hint = this.hints[index];
                    const hintPosition = new THREE.Vector3(
                        hint.position.x + this.modelOffset.x,
                        hint.position.y + this.modelOffset.y,
                        hint.position.z + this.modelOffset.z
                    );
                    
                    const distance = this.body.position.distanceTo(hintPosition);
                    const shouldBeVisible = this.showAllHints || distance <= this.hintVisibilityDistance;
                    
                    hintObj.sphere.visible = shouldBeVisible;
                });

                // Create 2D hint icons
                this.visibleHints.forEach((hint, index) => {
                    const hintElement = document.createElement('div');
                    hintElement.className = 'hint-icon';
                    hintElement.title = hint.title;
                    hintElement.dataset.hintIndex = index;

                    // Add click event
                    hintElement.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.showHintModal({
                            title: hint.title,
                            subtitle: hint.subtitle,
                            text: hint.text
                        });
                    });

                    this.hintsOverlay.appendChild(hintElement);
                });

                // Update positions
                this.updateHintPositions();
            }

            generateSamplePath() {
                if (!this.currentModel) {
                    alert('Please load a map first to generate a sample path.');
                    return;
                }

                // Get model bounding box to generate appropriate path
                const box = new THREE.Box3().setFromObject(this.currentModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Generate a simple rectangular path around the model
                const pathPoints = [];
                const steps = 20;
                const height = size.y * 0.3; // Path height

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const angle = t * Math.PI * 2;

                    // Create a circular path around the model center
                    const radius = Math.max(size.x, size.z) * 0.6;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;

                    pathPoints.push({
                        x: parseFloat((x + center.x - this.modelOffset.x).toFixed(3)),
                        y: parseFloat((height + center.y - this.modelOffset.y).toFixed(3)),
                        z: parseFloat((z + center.z - this.modelOffset.z).toFixed(3))
                    });
                }

                this.setPathFromData({ points: pathPoints });
            }

            generateSampleHints() {
                if (!this.currentModel) {
                    alert('Please load a map first to generate sample hints.');
                    return;
                }

                // Get model bounding box
                const box = new THREE.Box3().setFromObject(this.currentModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Generate sample hints at interesting positions
                const sampleHints = {
                    hints: [
                        {
                            title: "Welcome Point",
                            subtitle: "Starting Location",
                            text: "This is the starting point of your virtual tour. From here you can explore the entire environment.",
                            position: {
                                x: center.x - this.modelOffset.x,
                                y: center.y - this.modelOffset.y + 2,
                                z: center.z - this.modelOffset.z
                            },
                            sphereRadius: 2.0
                        },
                        {
                            title: "Observation Deck",
                            subtitle: "Best Viewpoint",
                            text: "This location offers a panoramic view of the entire scene. Perfect for taking in the surroundings.",
                            position: {
                                x: center.x - this.modelOffset.x + size.x * 0.3,
                                y: center.y - this.modelOffset.y + size.y * 0.5,
                                z: center.z - this.modelOffset.z
                            },
                            sphereRadius: 2.5
                        },
                        {
                            title: "Hidden Corner",
                            subtitle: "Secret Spot",
                            text: "You've found a hidden area! This spot contains special details that are easy to miss.",
                            position: {
                                x: center.x - this.modelOffset.x - size.x * 0.2,
                                y: center.y - this.modelOffset.y + 1,
                                z: center.z - this.modelOffset.z - size.z * 0.2
                            },
                            sphereRadius: 1.5
                        }
                    ]
                };

                this.setHintsFromData(sampleHints);
            }

            requestGyroscopePermission() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                this.gyroscopePermission = 'granted';
                                this.setupGyroscope();
                                this.updateUI();
                            } else {
                                this.gyroscopePermission = 'denied';
                                alert('Gyroscope access denied. You can still navigate using touch controls.');
                            }
                        })
                        .catch(console.error);
                } else {
                    // Non-iOS devices
                    this.gyroscopePermission = 'granted';
                    this.setupGyroscope();
                    this.updateUI();
                }
            }

            setupGyroscope() {
                window.addEventListener('deviceorientation', (event) => {
                    if (this.isPaused) return;
                    
                    this.gyroscopeData = {
                        alpha: event.alpha || 0,
                        beta: event.beta || 0,
                        gamma: event.gamma || 0
                    };
                });
            }

            toggleShowAllHints() {
                this.showAllHints = !this.showAllHints;
                const button = document.getElementById('toggle-hints-btn');
                button.textContent = this.showAllHints ? 'Hide All Hints' : 'Show All Hints';
                this.updateHintVisibility();
            }

            togglePlay() {
                if (this.isPaused) return;
                
                this.isPlaying = !this.isPlaying;
                const button = document.getElementById('play-btn');
                if (this.isPlaying) {
                    button.innerHTML = '<span class="icon icon-pause"></span><span>Pause</span>';
                } else {
                    button.innerHTML = '<span class="icon icon-play"></span><span>Play</span>';
                }
            }

            resetCamera() {
                if (this.isPaused) return;
                
                this.currentProgress = 0;
                this.velocity = 0;
                this.isPlaying = false;
                this.updateUI();

                const button = document.getElementById('play-btn');
                button.innerHTML = '<span class="icon icon-play"></span><span>Play</span>';
            }

            toggleUICollapse() {
                const panelContent = document.getElementById('panel-content');
                const collapseBtn = document.getElementById('collapse-btn');
                const icon = collapseBtn.querySelector('.icon');

                if (panelContent.style.display === 'none') {
                    panelContent.style.display = 'block';
                    icon.textContent = '‚Üë';
                } else {
                    panelContent.style.display = 'none';
                    icon.textContent = '‚Üì';
                }
            }

            updateMapLoadStatus(message, status) {
                this.mapLoadStatus.textContent = message;
                this.mapLoadStatus.className = 'text-xs p-2 rounded';

                switch (status) {
                    case 'loading':
                        this.mapLoadStatus.classList.add('status-loading');
                        break;
                    case 'success':
                        this.mapLoadStatus.classList.add('status-success');
                        break;
                    case 'error':
                        this.mapLoadStatus.classList.add('status-error');
                        break;
                }

                this.mapLoadStatus.classList.remove('hidden');
            }

            updateUI() {
                // Update path controls visibility
                const pathControls = document.getElementById('path-controls');
                if (this.curve) {
                    pathControls.classList.remove('hidden');
                } else {
                    pathControls.classList.add('hidden');
                }

                // Update mobile status
                if (this.isMobile) {
                    const gyroStatus = document.getElementById('gyro-status');
                    if (this.gyroscopePermission === 'granted') {
                        gyroStatus.textContent = '‚úÖ Gyroscope enabled';
                        document.getElementById('gyro-prompt').classList.add('hidden');
                    } else {
                        gyroStatus.textContent = '‚ö†Ô∏è Gyroscope disabled';
                        document.getElementById('gyro-prompt').classList.remove('hidden');
                    }
                }
            }

            onWindowResize() {
                if (!this.camera || !this.renderer) return;

                this.camera.aspect = this.canvasContainer.clientWidth / this.canvasContainer.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (!this.isPaused) {
                    this.updateCameraPosition();
                    this.updateCameraRotation();
                    
                    // –û–ë–ù–û–í–õ–Ø–ï–ú –ü–û–ó–ò–¶–ò–ò –ò–ö–û–ù–û–ö –°–†–ê–ó–£ –ü–û–°–õ–ï –í–†–ê–©–ï–ù–ò–Ø –ö–ê–ú–ï–†–´
                    this.updateHintPositions();
                } else {
                    // –ï—Å–ª–∏ –Ω–∞ –ø–∞—É–∑–µ, –≤—Å–µ —Ä–∞–≤–Ω–æ –æ–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏–∏ –∏–∫–æ–Ω–æ–∫
                    this.updateHintPositions();
                }

                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            }

            updateCameraPosition() {
                if (!this.curve) return;

                // Apply acceleration/deceleration for smooth movement
                if (Math.abs(this.velocity) > 0.0001) {
                    this.velocity *= this.deceleration;
                } else {
                    this.velocity = 0;
                }

                // Auto-play if enabled
                if (this.isPlaying) {
                    this.velocity += this.acceleration * this.scrollingSpeed;
                }

                // Clamp velocity to max speed
                this.velocity = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.velocity));

                // Update progress along the path
                this.currentProgress += this.velocity;

                // Handle looping (infinite path)
                if (this.currentProgress < 0) {
                    this.currentProgress = 1 + (this.currentProgress % 1);
                } else if (this.currentProgress > 1) {
                    this.currentProgress = this.currentProgress % 1;
                }

                // Get position from curve
                const position = this.curve.getPoint(this.currentProgress);
                this.body.position.copy(position);

                // Calculate look direction (tangent to the curve)
                const tangent = this.curve.getTangent(this.currentProgress);
                if (tangent.length() > 0.001) {
                    this.body.lookAt(position.clone().add(tangent));
                }

                // Update progress UI
                const progressPercent = Math.round(this.currentProgress * 100);
                document.getElementById('progress-percent').textContent = progressPercent;
                document.getElementById('progress-fill').style.width = progressPercent + '%';
            }
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new VirtualTour();
        });
    </script>
</body>
</html>
