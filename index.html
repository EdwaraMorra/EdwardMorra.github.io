<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Virtual Tour</title>

    <!-- Three.js Module Import -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* UI Components Styles */
        .card {
            background: white;
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }

        .card-header {
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            line-height: 1;
            letter-spacing: -0.025em;
        }

        .card-content {
            padding: 1.5rem;
            padding-top: 0;
        }

        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 0.2s;
            border: none;
            cursor: pointer;
            gap: 0.5rem;
        }

        .button:disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        .button-default {
            background: #2563eb;
            color: white;
        }

        .button-default:hover {
            background: #1d4ed8;
        }

        .button-destructive {
            background: #dc2626;
            color: white;
        }

        .button-destructive:hover {
            background: #b91c1c;
        }

        .button-outline {
            background: transparent;
            border: 1px solid #d1d5db;
            color: inherit;
        }

        .button-outline:hover {
            background: #f9fafb;
        }

        .button-ghost {
            background: transparent;
            color: inherit;
            border: none;
        }

        .button-ghost:hover {
            background: #f9fafb;
        }

        .button-sm {
            height: 2.25rem;
            padding: 0 0.75rem;
            font-size: 0.875rem;
        }

        .button-default-size {
            height: 2.5rem;
            padding: 0 1rem;
        }

        .space-y-2 > * + * {
            margin-top: 0.5rem;
        }

        .space-y-3 > * + * {
            margin-top: 0.75rem;
        }

        .space-x-2 > * + * {
            margin-left: 0.5rem;
        }

        .flex {
            display: flex;
        }

        .items-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .w-full {
            width: 100%;
        }

        .w-80 {
            width: 20rem;
        }

        .h-8 {
            height: 2rem;
        }

        .h-9 {
            height: 2.25rem;
        }

        .h-10 {
            height: 2.5rem;
        }

        .w-8 {
            width: 2rem;
        }

        .p-0 {
            padding: 0;
        }

        .p-2 {
            padding: 0.5rem;
        }

        .p-4 {
            padding: 1rem;
        }

        .text-sm {
            font-size: 0.875rem;
        }

        .text-xs {
            font-size: 0.75rem;
        }

        .text-lg {
            font-size: 1.125rem;
        }

        .text-xl {
            font-size: 1.25rem;
        }

        .font-medium {
            font-weight: 500;
        }

        .font-semibold {
            font-weight: 600;
        }

        .text-gray-600 {
            color: #4b5563;
        }

        .text-gray-800 {
            color: #1f2937;
        }

        .text-blue-600 {
            color: #2563eb;
        }

        .text-blue-800 {
            color: #1e40af;
        }

        .bg-white {
            background: white;
        }

        .bg-blue-50 {
            background: #eff6ff;
        }

        .bg-blue-100 {
            background: #dbeafe;
        }

        .bg-gray-200 {
            background: #e5e7eb;
        }

        .bg-blue-600 {
            background: #2563eb;
        }

        .bg-black {
            background: black;
        }

        .bg-opacity-50 {
            opacity: 0.5;
        }

        .bg-opacity-90 {
            opacity: 0.9;
        }

        .rounded {
            border-radius: 0.25rem;
        }

        .rounded-full {
            border-radius: 9999px;
        }

        .rounded-lg {
            border-radius: 0.5rem;
        }

        .border {
            border: 1px solid #e5e7eb;
        }

        .border-2 {
            border-width: 2px;
        }

        .border-blue-200 {
            border-color: #bfdbfe;
        }

        .border-blue-500 {
            border-color: #3b82f6;
        }

        .shadow-lg {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .absolute {
            position: absolute;
        }

        .relative {
            position: relative;
        }

        .inset-0 {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
        }

        .top-4 {
            top: 1rem;
        }

        .left-4 {
            left: 1rem;
        }

        .z-10 {
            z-index: 10;
        }

        .z-20 {
            z-index: 20;
        }

        .z-30 {
            z-index: 30;
        }

        .z-40 {
            z-index: 40;
        }

        .pointer-events-none {
            pointer-events: none;
        }

        .pointer-events-auto {
            pointer-events: auto;
        }

        .cursor-pointer {
            cursor: pointer;
        }

        .transform {
            transform: translate(var(--tw-translate-x), var(--tw-translate-y));
        }

        .-translate-x-1-2 {
            transform: translateX(-50%);
        }

        .-translate-y-1-2 {
            transform: translateY(-50%);
        }

        .transition-all {
            transition: all 0.2s;
        }

        .duration-200 {
            transition-duration: 200ms;
        }

        .duration-300 {
            transition-duration: 300ms;
        }

        .hidden {
            display: none;
        }

        .block {
            display: block;
        }

        .flex-1 {
            flex: 1;
        }

        .max-w-90vw {
            max-width: 90vw;
        }

        .max-w-sm {
            max-width: 24rem;
        }

        .h-2 {
            height: 0.5rem;
        }

        .h-screen {
            height: 100vh;
        }

        .touch-none {
            touch-action: none;
        }

        .overflow-hidden {
            overflow: hidden;
        }

        .leading-relaxed {
            line-height: 1.625;
        }

        .mt-1 {
            margin-top: 0.25rem;
        }

        .mb-4 {
            margin-bottom: 1rem;
        }

        .hover-bg-opacity-100:hover {
            opacity: 1;
        }

        input[type="range"] {
            width: 100%;
            height: 0.375rem;
            border-radius: 0.25rem;
            background: #d1d5db;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            border: none;
        }

        .progress-bar {
            width: 100%;
            background: #e5e7eb;
            border-radius: 9999px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #2563eb;
            transition: width 0.2s;
        }

        .status-loading {
            background: rgba(255, 193, 7, 0.2);
            color: #ffa000;
            border-left: 4px solid #ffc107;
        }

        .status-success {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
            border-left: 4px solid #4caf50;
        }

        .status-error {
            background: rgba(244, 67, 54, 0.2);
            color: #f44336;
            border-left: 4px solid #f44336;
        }

        /* Simple icon styles */
        .icon {
            width: 1rem;
            height: 1rem;
            display: inline-block;
        }

        .icon-upload::before {
            content: 'üì§';
        }

        .icon-rotate-ccw::before {
            content: 'üîÑ';
        }

        .icon-play::before {
            content: '‚ñ∂Ô∏è';
        }

        .icon-pause::before {
            content: '‚è∏Ô∏è';
        }

        .icon-eye::before {
            content: 'üëÅÔ∏è';
        }

        .icon-x::before {
            content: '‚ùå';
        }

        .icon-map-pin::before {
            content: 'üìç';
        }

        .icon-chevron-up::before {
            content: '‚Üë';
        }

        .icon-chevron-down::before {
            content: '‚Üì';
        }

        /* Hint Modal Styles */
        #hint-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(4px);
        }

        .hint-modal-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            padding: 0;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            overflow: hidden;
        }

        .hint-modal-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .hint-modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #1f2937;
        }

        .hint-modal-subtitle {
            font-size: 1rem;
            color: #6b7280;
        }

        .hint-modal-body {
            padding: 1.5rem;
            line-height: 1.6;
            color: #374151;
        }

        .hint-modal-footer {
            padding: 1rem 1.5rem 1.5rem;
            display: flex;
            justify-content: flex-end;
        }

        .hint-modal-close-btn {
            background: #2563eb;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.375rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .hint-modal-close-btn:hover {
            background: #1d4ed8;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- 2D Hint Icons Overlay -->
    <div id="hints-overlay" class="absolute inset-0 pointer-events-none z-30"></div>

    <!-- Control Panel -->
    <div id="control-panel" class="absolute top-4 left-4 z-20 transition-all duration-300 w-80 max-w-90vw">
        <div class="card relative">
            <div class="card-header pb-2">
                <div class="flex items-center justify-between">
                    <h3 class="card-title text-lg" id="panel-title">3D Tour Controls</h3>
                    <button id="collapse-btn" class="button button-ghost h-8 w-8 p-0">
                        <span class="icon icon-chevron-up"></span>
                    </button>
                </div>
            </div>

            <div id="panel-content" class="card-content space-y-3">
                <!-- Mobile gyroscope permission -->
                <div id="gyro-prompt" class="space-y-2 hidden">
                    <button id="enable-gyro-btn" class="button button-outline w-full text-sm">
                        üéØ Enable Gyroscope Control
                    </button>
                </div>

                <!-- Mobile status indicator -->
                <div id="mobile-status" class="text-xs bg-blue-50 p-2 rounded border border-blue-200 hidden">
                    <p class="font-medium text-blue-800">üì± Mobile Mode Active</p>
                    <p id="gyro-status" class="text-blue-600">‚ö†Ô∏è Gyroscope disabled</p>
                </div>

                <!-- Map loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Load Map/Environment:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json,.glb,.gltf" id="map-upload" class="hidden">
                        <button id="load-map-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-upload"></span>
                            <span>Load Map</span>
                        </button>
                    </div>
                    <!-- Status for GLTF loading -->
                    <div id="map-load-status" class="text-xs p-2 rounded hidden"></div>
                </div>

                <!-- Path loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Camera Path:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json" id="path-upload" class="hidden">
                        <button id="load-path-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-upload"></span>
                            <span>Load Path</span>
                        </button>
                        <button id="sample-path-btn" class="button button-outline button-sm text-xs">
                            Sample Path
                        </button>
                    </div>
                </div>

                <!-- Hints loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Hints:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json" id="hint-upload" class="hidden">
                        <button id="load-hints-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-map-pin"></span>
                            <span>Load Hints</span>
                        </button>
                        <button id="sample-hints-btn" class="button button-outline button-sm text-xs">
                            Sample Hints
                        </button>
                    </div>
                </div>

                <!-- Annotation loading -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Annotations:</label>
                    <div class="flex items-center space-x-2">
                        <input type="file" accept=".json" id="annotation-upload" class="hidden">
                        <button id="load-annotations-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-map-pin"></span>
                            <span>Load Annotations</span>
                        </button>
                        <button id="sample-annotations-btn" class="button button-outline button-sm text-xs">
                            Sample Annotations
                        </button>
                    </div>
                </div>

                <!-- Hint settings -->
                <div class="space-y-2">
                    <label class="block text-sm font-medium">Hint Settings:</label>
                    <div class="space-y-2">
                        <button id="toggle-hints-btn" class="button button-outline button-sm w-full text-xs">
                            Show All Hints
                        </button>
                        <div class="flex items-center space-x-2">
                            <label class="text-xs">Distance:</label>
                            <input type="range" min="5" max="50" value="15" id="hint-distance-slider" class="flex-1">
                            <span id="hint-distance-value" class="text-xs w-8">15</span>
                        </div>
                    </div>
                </div>

                <!-- Path controls -->
                <div id="path-controls" class="space-y-2 hidden">
                    <label class="block text-sm font-medium">Path Progress: <span id="progress-percent">0</span>%</label>
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
                    </div>

                    <div class="space-y-2">
                        <label class="block text-sm font-medium">Scrolling Speed:</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs w-8">0.1x</span>
                            <input type="range" min="0.1" max="3.0" step="0.1" value="1.0" id="speed-slider" class="flex-1">
                            <span class="text-xs w-8">3.0x</span>
                        </div>
                        <div class="text-center">
                            <span id="speed-display" class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">1.0x speed</span>
                        </div>
                    </div>

                    <!-- Path Smoothing Control -->
                    <div class="space-y-2">
                        <label class="block text-sm font-medium">Path Smoothing:</label>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs w-8">Low</span>
                            <input type="range" min="0.0" max="1.0" step="0.1" value="0.5" id="smoothing-slider" class="flex-1">
                            <span class="text-xs w-8">High</span>
                        </div>
                        <div class="text-center">
                            <span id="smoothing-display" class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">Medium smoothing</span>
                        </div>
                    </div>

                    <div class="flex space-x-2">
                        <button id="play-btn" class="button button-default button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-play"></span>
                            <span>Play</span>
                        </button>
                        <button id="reset-btn" class="button button-outline button-sm flex items-center space-x-1 text-xs">
                            <span class="icon icon-rotate-ccw"></span>
                            <span>Reset</span>
                        </button>
                    </div>
                </div>

                <!-- Instructions -->
                <div class="text-xs text-gray-600 space-y-1">
                    <p><strong>üñ±Ô∏è Mouse:</strong> Move to look around (click to lock pointer)</p>
                    <p><strong>üé° Mouse Wheel:</strong> Navigate along path (infinite loop)</p>
                    <p><strong>üí° Hints:</strong> Click 2D icons to view information</p>
                    <p><strong>üìù Annotations:</strong> Click annotation spheres to view details</p>
                    <p><strong>üö´ No Page Scroll:</strong> All scrolling disabled</p>
                    <p><strong>‚ö° Speed Control:</strong> Adjust scrolling speed (0.1x - 3.0x)</p>
                    <p><strong>üîÑ Path Smoothing:</strong> Control how smooth the path is between points</p>
                    <p><strong>üó∫Ô∏è Map Format:</strong> GLB, GLTF files supported</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Hint Modal -->
    <div id="hint-modal">
        <div class="hint-modal-content">
            <div class="hint-modal-header">
                <h2 id="hint-modal-title" class="hint-modal-title">Hint Title</h2>
                <p id="hint-modal-subtitle" class="hint-modal-subtitle">Hint Subtitle</p>
            </div>
            <div class="hint-modal-body">
                <p id="hint-modal-text">Hint text content will appear here when you click on a hint icon.</p>
            </div>
            <div class="hint-modal-footer">
                <button id="hint-modal-close-btn" class="hint-modal-close-btn">Close</button>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 z-40">
        <div class="text-white text-xl">Loading 3D Scene...</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Main application
        class VirtualTour {
            constructor() {
                this.scene = null;
                this.renderer = null;
                this.camera = null;
                this.gltfLoader = null;

                // Camera system
                this.body = null;
                this.path = [];
                this.curve = null;
                this.currentProgress = 0;
                this.velocity = 0;
                this.isPlaying = false;

                // Camera rotation
                this.pitch = 0;
                this.yaw = 0;
                this.isPointerLocked = false;

                this.hints = [];
                this.visibleHints = [];
                this.annotations = [];
                this.annotationSpheres = [];

                // Current model
                this.currentModel = null;
                this.modelOffset = new THREE.Vector3(0, 0, 0);

                // Mobile-specific
                this.isMobile = false;
                this.gyroscopeSupported = false;
                this.gyroscopePermission = 'prompt';
                this.gyroscopeData = { alpha: 0, beta: 0, gamma: 0 };

                // Settings
                this.scrollingSpeed = 1.0;
                this.showAllHints = false;
                this.hintVisibilityDistance = 15;
                this.pathSmoothing = 0.5;

                // Modal state
                this.isModalOpen = false;

                // DOM elements
                this.canvasContainer = document.getElementById('canvas-container');
                this.hintsOverlay = document.getElementById('hints-overlay');
                this.controlPanel = document.getElementById('control-panel');
                this.mapLoadStatus = document.getElementById('map-load-status');
                this.hintModal = document.getElementById('hint-modal');

                // Raycaster for annotations
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                // Inertia parameters
                this.acceleration = 0.0005;
                this.deceleration = 0.95;
                this.maxSpeed = 0.02;

                this.init();
            }

            init() {
                this.detectMobile();
                this.setupEventListeners();
                this.initThreeJS();
                this.loadDefaultMap();
                this.updateUI();
            }

            detectMobile() {
                this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                              (window.innerWidth <= 768);

                if (this.isMobile && 'DeviceOrientationEvent' in window) {
                    this.gyroscopeSupported = true;
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        this.gyroscopePermission = 'prompt';
                    } else {
                        this.gyroscopePermission = 'granted';
                    }
                }

                // Update UI for mobile
                if (this.isMobile) {
                    document.getElementById('panel-title').textContent += ' üì±';
                    document.getElementById('gyro-prompt').classList.remove('hidden');
                    document.getElementById('mobile-status').classList.remove('hidden');

                    // Update instructions for mobile
                    const instructions = document.querySelector('.text-xs.text-gray-600');
                    instructions.innerHTML = `
                        <p><strong>üì± Gyroscope:</strong> Tilt device to look around</p>
                        <p><strong>üëÜ Touch Scroll:</strong> Swipe vertically to navigate path</p>
                        <p><strong>üí° Hints:</strong> Tap 2D icons to view information</p>
                        <p><strong>üìù Annotations:</strong> Tap annotation spheres to view details</p>
                        <p><strong>üö´ No Page Scroll:</strong> All scrolling disabled</p>
                        <p><strong>‚ö° Speed Control:</strong> Adjust scrolling speed (0.1x - 3.0x)</p>
                        <p><strong>üîÑ Path Smoothing:</strong> Control how smooth the path is between points</p>
                        <p><strong>üó∫Ô∏è Map Format:</strong> GLB, GLTF files supported</p>
                    `;
                }
            }

            setupEventListeners() {
                // File uploads
                document.getElementById('load-map-btn').addEventListener('click', () => {
                    document.getElementById('map-upload').click();
                });
                document.getElementById('load-path-btn').addEventListener('click', () => {
                    document.getElementById('path-upload').click();
                });
                document.getElementById('load-hints-btn').addEventListener('click', () => {
                    document.getElementById('hint-upload').click();
                });
                document.getElementById('load-annotations-btn').addEventListener('click', () => {
                    document.getElementById('annotation-upload').click();
                });

                document.getElementById('map-upload').addEventListener('change', (e) => this.handleMapLoad(e));
                document.getElementById('path-upload').addEventListener('change', (e) => this.handlePathLoad(e));
                document.getElementById('hint-upload').addEventListener('change', (e) => this.handleHintLoad(e));
                document.getElementById('annotation-upload').addEventListener('change', (e) => this.handleAnnotationLoad(e));

                // Buttons
                document.getElementById('sample-path-btn').addEventListener('click', () => this.generateSamplePath());
                document.getElementById('sample-hints-btn').addEventListener('click', () => this.generateSampleHints());
                document.getElementById('sample-annotations-btn').addEventListener('click', () => this.generateSampleAnnotations());
                document.getElementById('enable-gyro-btn').addEventListener('click', () => this.requestGyroscopePermission());
                document.getElementById('toggle-hints-btn').addEventListener('click', () => this.toggleShowAllHints());
                document.getElementById('play-btn').addEventListener('click', () => this.togglePlay());
                document.getElementById('reset-btn').addEventListener('click', () => this.resetCamera());
                document.getElementById('collapse-btn').addEventListener('click', () => this.toggleUICollapse());
                document.getElementById('hint-modal-close-btn').addEventListener('click', () => this.closeHintModal());

                // Sliders
                document.getElementById('hint-distance-slider').addEventListener('input', (e) => {
                    this.hintVisibilityDistance = parseInt(e.target.value);
                    document.getElementById('hint-distance-value').textContent = this.hintVisibilityDistance;
                });

                document.getElementById('speed-slider').addEventListener('input', (e) => {
                    this.scrollingSpeed = parseFloat(e.target.value);
                    document.getElementById('speed-display').textContent = this.scrollingSpeed + 'x speed';
                });

                // Path smoothing slider
                document.getElementById('smoothing-slider').addEventListener('input', (e) => {
                    this.pathSmoothing = parseFloat(e.target.value);
                    this.updateSmoothingDisplay();
                    // Update path with new smoothing
                    if (this.path.length > 0) {
                        this.setPathFromData({ points: this.path });
                    }
                });

                // Click event for annotations
                this.renderer?.domElement.addEventListener('click', (event) => this.handleAnnotationClick(event));
            }

            updateSmoothingDisplay() {
                let smoothingText;
                if (this.pathSmoothing < 0.3) {
                    smoothingText = "Low smoothing";
                } else if (this.pathSmoothing < 0.7) {
                    smoothingText = "Medium smoothing";
                } else {
                    smoothingText = "High smoothing";
                }
                document.getElementById('smoothing-display').textContent = smoothingText;
            }

            initThreeJS() {
                // Scene setup
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB);

                // Create body that moves along the path
                this.body = new THREE.Object3D();
                this.scene.add(this.body);

                // Camera setup
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    this.canvasContainer.clientWidth / this.canvasContainer.clientHeight,
                    0.1,
                    1000
                );
                this.body.add(this.camera);
                this.camera.position.set(0, 0, 0);

                // Set camera rotation order to prevent roll
                this.camera.rotation.order = 'YXZ';

                // Renderer setup
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
                this.canvasContainer.appendChild(this.renderer.domElement);

                // GLTF Loader
                this.gltfLoader = new GLTFLoader();

                // Setup controls
                this.setupControls();

                // Start animation loop
                this.animate();

                // Hide loading overlay
                document.getElementById('loading-overlay').classList.add('hidden');
            }

            loadDefaultMap() {
                // Load default map from map.glb
                this.updateMapLoadStatus('Loading default map...', 'loading');

                this.gltfLoader.load(
                    'map.glb',

                    // onLoad callback
                    (gltf) => {
                        // Remove previous model if exists
                        if (this.currentModel) {
                            this.scene.remove(this.currentModel);
                        }

                        const model = gltf.scene;
                        this.currentModel = model;

                        // Configure the model
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        // Calculate model bounding box and center
                        const box = new THREE.Box3().setFromObject(model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());

                        // Calculate the offset needed to center the model
                        this.modelOffset = center.clone().multiplyScalar(-1);

                        // Center the model at origin
                        model.position.copy(this.modelOffset);

                        // Add to scene
                        this.scene.add(model);

                        // Load default path after map is loaded
                        this.loadDefaultPath();

                        // Update status
                        this.updateMapLoadStatus(`Default map loaded successfully! Size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'success');
                    },

                    // onProgress callback
                    (xhr) => {
                        if (xhr.lengthComputable) {
                            const percentComplete = (xhr.loaded / xhr.total * 100).toFixed(2);
                            this.updateMapLoadStatus(`Loading default map: ${percentComplete}%`, 'loading');
                        }
                    },

                    // onError callback
                    (error) => {
                        console.error('Error loading default map:', error);
                        this.updateMapLoadStatus('Default map not found. You can load a map manually.', 'error');
                        // Load default path even if map fails
                        this.loadDefaultPath();
                    }
                );
            }

            loadDefaultPath() {
                // Load default path from path.json
                fetch('path.json')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Path file not found');
                        }
                        return response.json();
                    })
                    .then(data => {
                        this.setPathFromData(data);
                    })
                    .catch(error => {
                        console.error('Error loading default path:', error);
                        // Generate sample path if default path not found
                        this.generateSamplePath();
                    });
            }

            setPathFromData(pathData) {
                // Clear existing path visualization
                if (this.pathLine) {
                    this.scene.remove(this.pathLine);
                }

                // Convert points to Vector3 with high precision
                const points = pathData.points.map(p => {
                    return new THREE.Vector3(
                        parseFloat(p.x.toFixed(15)),
                        parseFloat(p.y.toFixed(15)),
                        parseFloat(p.z.toFixed(15))
                    );
                });

                // Apply model offset to align path with model
                const adjustedPoints = points.map(point =>
                    point.clone().add(this.modelOffset)
                );

                // Create curve from points with adjustable smoothing
                this.curve = this.createSmoothCurve(adjustedPoints);

                // Check if curve was created successfully
                if (!this.curve) {
                    console.error('Failed to create path curve');
                    return;
                }

                // Create visualization
                const pathGeometry = new THREE.BufferGeometry().setFromPoints(this.curve.getPoints(500));
                const pathMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                this.pathLine = new THREE.Line(pathGeometry, pathMaterial);
                  // this.scene.add(this.pathLine);

                // Set initial position
                if (points.length > 0) {
                    const initialPoint = this.curve.getPoint(0);
                    this.body.position.copy(initialPoint);

                    // Look along the path
                    const lookAtPoint = this.curve.getPoint(0.01);
                    this.body.lookAt(lookAtPoint);
                }

                this.updateUI();
            }

            createSmoothCurve(points) {
                // Check if we have enough points
                if (points.length < 2) {
                    console.warn('Not enough points to create curve');
                    return null;
                }

                // Create a CatmullRom curve with adjustable tension based on smoothing
                const curve = new THREE.CatmullRomCurve3(points);
                curve.curveType = 'centripetal'; // 'centripetal', 'chordal', 'catmullrom'

                // Adjust tension based on smoothing value (0.0 - 1.0)
                // Lower smoothing = more direct path, higher smoothing = smoother path
                curve.tension = this.pathSmoothing;

                return curve;
            }

            setupControls() {
                // Pointer lock for desktop
                this.renderer.domElement.addEventListener('click', () => {
                    if (!this.isPointerLocked && !this.isMobile) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });

                // Pointer lock change event
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                });

                // Mouse movement for camera rotation
                document.addEventListener('mousemove', (event) => {
                    if (this.isPointerLocked && !this.isMobile) {
                        const movementX = event.movementX || 0;
                        const movementY = event.movementY || 0;

                        this.yaw -= movementX * 0.002;
                        this.pitch -= movementY * 0.002;

                        // Clamp pitch to prevent flipping
                        this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
                    }
                });

                // Mouse wheel for path navigation
                document.addEventListener('wheel', (event) => {
                    event.preventDefault();

                    // Calculate velocity based on wheel delta and speed setting
                    const delta = -Math.sign(event.deltaY) * 0.0005 * this.scrollingSpeed;
                    this.velocity += delta;

                    // Clamp velocity to max speed
                    this.velocity = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.velocity));
                }, { passive: false });

                // Touch events for mobile
                if (this.isMobile) {
                    let touchStartY = 0;
                    let isScrolling = false;

                    document.addEventListener('touchstart', (event) => {
                        if (event.touches.length === 1) {
                            touchStartY = event.touches[0].clientY;
                            isScrolling = true;
                        }
                    }, { passive: true });

                    document.addEventListener('touchmove', (event) => {
                        if (isScrolling && event.touches.length === 1) {
                            const touchY = event.touches[0].clientY;
                            const deltaY = touchStartY - touchY;

                            // Apply velocity based on touch movement
                            this.velocity = deltaY * 0.0001 * this.scrollingSpeed;

                            touchStartY = touchY;
                        }
                    }, { passive: true });

                    document.addEventListener('touchend', () => {
                        isScrolling = false;
                    }, { passive: true });
                }

                // Prevent default scroll behavior
                document.addEventListener('scroll', (e) => e.preventDefault());
                document.addEventListener('wheel', (e) => e.preventDefault(), { passive: false });
                document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });

                // Window resize
                window.addEventListener('resize', () => this.onWindowResize());
            }

            updateCameraRotation() {
                if (this.isMobile && this.gyroscopePermission === 'granted') {
                    // Use gyroscope data for mobile
                    const { alpha, beta, gamma } = this.gyroscopeData;

                    // Convert device orientation to camera rotation
                    this.yaw = -alpha * (Math.PI / 180); // Convert degrees to radians
                    this.pitch = beta * (Math.PI / 180) - Math.PI / 2; // Adjust pitch range

                    // Clamp pitch
                    this.pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.pitch));
                }

                // Apply rotation to camera
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = this.yaw;
                this.camera.rotation.x = this.pitch;
                this.camera.rotation.z = 0; // Prevent roll
            }

            handleMapLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.updateMapLoadStatus(`Loading ${file.name}...`, 'loading');

                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;

                    this.gltfLoader.parse(
                        arrayBuffer,
                        '',
                        (gltf) => {
                            // Remove previous model if exists
                            if (this.currentModel) {
                                this.scene.remove(this.currentModel);
                            }

                            const model = gltf.scene;
                            this.currentModel = model;

                            // Configure the model
                            model.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });

                            // Calculate model bounding box and center
                            const box = new THREE.Box3().setFromObject(model);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());

                            // Calculate the offset needed to center the model
                            this.modelOffset = center.clone().multiplyScalar(-1);

                            // Center the model at origin
                            model.position.copy(this.modelOffset);

                            // Add to scene
                            this.scene.add(model);

                            this.updateMapLoadStatus(`${file.name} loaded successfully! Size: ${size.x.toFixed(2)} x ${size.y.toFixed(2)} x ${size.z.toFixed(2)}`, 'success');

                            // Reset path and camera when new map is loaded
                            this.path = [];
                            this.curve = null;
                            this.currentProgress = 0;
                            this.velocity = 0;
                            this.isPlaying = false;
                            this.updateUI();
                        },
                        (error) => {
                            console.error('Error loading GLTF:', error);
                            this.updateMapLoadStatus(`Error loading ${file.name}: ${error.message}`, 'error');
                        }
                    );
                };

                reader.readAsArrayBuffer(file);
                event.target.value = ''; // Reset file input
            }

            handlePathLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const pathData = JSON.parse(e.target.result);
                        this.setPathFromData(pathData);
                    } catch (error) {
                        console.error('Error parsing path file:', error);
                        alert('Error loading path file: ' + error.message);
                    }
                };

                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            }

            handleHintLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const hintData = JSON.parse(e.target.result);
                        this.setHintsFromData(hintData);
                    } catch (error) {
                        console.error('Error parsing hint file:', error);
                        alert('Error loading hint file: ' + error.message);
                    }
                };

                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            }

            handleAnnotationLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const annotationData = JSON.parse(e.target.result);
                        this.setAnnotationsFromData(annotationData);
                    } catch (error) {
                        console.error('Error parsing annotation file:', error);
                        alert('Error loading annotation file: ' + error.message);
                    }
                };

                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            }

            setHintsFromData(hintData) {
                this.hints = hintData.hints || [];
                this.updateHintOverlay();
            }

            setAnnotationsFromData(annotationData) {
                // Clear existing annotations
                this.annotations.forEach(annotation => {
                    this.scene.remove(annotation.sphere);
                });
                this.annotations = [];
                this.annotationSpheres = [];

                // Add new annotations
                annotationData.annotations.forEach((annotation, index) => {
                    this.addAnnotation(annotation, index);
                });
            }

            addAnnotation(annotationData, index) {
                // Create invisible sphere for interaction
                const sphereGeometry = new THREE.SphereGeometry(annotationData.sphereRadius || 1, 8, 6);
                const sphereMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.0 // Completely invisible
                });

                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(
                    annotationData.spherePosition.x,
                    annotationData.spherePosition.y,
                    annotationData.spherePosition.z
                );

                // Store annotation data
                sphere.userData = {
                    isAnnotation: true,
                    annotationIndex: index,
                    title: annotationData.title,
                    subtitle: annotationData.subtitle,
                    text: annotationData.text
                };

                this.scene.add(sphere);
                this.annotations.push({
                    data: annotationData,
                    sphere: sphere
                });
                this.annotationSpheres.push(sphere);
            }

            handleAnnotationClick(event) {
                if (this.isModalOpen) return;

                // Calculate mouse position in normalized device coordinates
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                // Update the raycaster
                this.raycaster.setFromCamera(this.mouse, this.camera);

                // Check for intersection with annotation spheres
                const intersects = this.raycaster.intersectObjects(this.annotationSpheres);

                if (intersects.length > 0) {
                    const sphere = intersects[0].object;
                    const annotationData = sphere.userData;

                    // Show modal with annotation data
                    this.showAnnotationModal(annotationData);
                }
            }

            showAnnotationModal(annotationData) {
                document.getElementById('hint-modal-title').textContent = annotationData.title;
                document.getElementById('hint-modal-subtitle').textContent = annotationData.subtitle;
                document.getElementById('hint-modal-text').textContent = annotationData.text;
                this.hintModal.style.display = 'flex';
                this.isModalOpen = true;
            }

            closeHintModal() {
                this.hintModal.style.display = 'none';
                this.isModalOpen = false;
            }

            updateHintOverlay() {
                // Clear existing hints
                this.hintsOverlay.innerHTML = '';

                // Filter visible hints based on distance
                this.visibleHints = this.hints.filter(hint => {
                    if (this.showAllHints) return true;

                    const hintPosition = new THREE.Vector3(
                        hint.position.x + this.modelOffset.x,
                        hint.position.y + this.modelOffset.y,
                        hint.position.z + this.modelOffset.z
                    );

                    const distance = this.body.position.distanceTo(hintPosition);
                    return distance <= this.hintVisibilityDistance;
                });

                // Create 2D hint icons
                this.visibleHints.forEach((hint, index) => {
                    const hintElement = document.createElement('div');
                    hintElement.className = 'absolute w-8 h-8 bg-blue-600 rounded-full cursor-pointer pointer-events-auto transform -translate-x-1/2 -translate-y-1/2 z-30';
                    hintElement.innerHTML = 'üí°';
                    hintElement.title = hint.title;

                    // Position will be updated in animate loop
                    hintElement.dataset.hintIndex = index;

                    this.hintsOverlay.appendChild(hintElement);

                    // Add click event
                    hintElement.addEventListener('click', () => {
                        this.showHintModal(hint);
                    });
                });
            }

            showHintModal(hint) {
                document.getElementById('hint-modal-title').textContent = hint.title;
                document.getElementById('hint-modal-subtitle').textContent = hint.subtitle;
                document.getElementById('hint-modal-text').textContent = hint.text;
                this.hintModal.style.display = 'flex';
                this.isModalOpen = true;
            }

            updateHintPositions() {
                const hintElements = this.hintsOverlay.querySelectorAll('div');
                hintElements.forEach(element => {
                    const hintIndex = parseInt(element.dataset.hintIndex);
                    const hint = this.visibleHints[hintIndex];

                    if (hint) {
                        const hintPosition = new THREE.Vector3(
                            hint.position.x + this.modelOffset.x,
                            hint.position.y + this.modelOffset.y,
                            hint.position.z + this.modelOffset.z
                        );

                        // Convert 3D position to 2D screen position
                        const screenPosition = hintPosition.clone();
                        screenPosition.project(this.camera);

                        // Check if hint is in front of camera
                        if (screenPosition.z > 0 && screenPosition.z < 1) {
                            const x = (screenPosition.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-(screenPosition.y * 0.5) + 0.5) * window.innerHeight;

                            element.style.left = x + 'px';
                            element.style.top = y + 'px';
                            element.style.display = 'block';
                        } else {
                            element.style.display = 'none';
                        }
                    }
                });
            }

            generateSamplePath() {
                if (!this.currentModel) {
                    alert('Please load a map first to generate a sample path.');
                    return;
                }

                // Get model bounding box to generate appropriate path
                const box = new THREE.Box3().setFromObject(this.currentModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Generate a simple rectangular path around the model
                const pathPoints = [];
                const steps = 20;
                const height = size.y * 0.3; // Path height

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const angle = t * Math.PI * 2;

                    // Create a circular path around the model center
                    const radius = Math.max(size.x, size.z) * 0.6;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;

                    pathPoints.push({
                        x: parseFloat((x + center.x - this.modelOffset.x).toFixed(3)),
                        y: parseFloat((height + center.y - this.modelOffset.y).toFixed(3)),
                        z: parseFloat((z + center.z - this.modelOffset.z).toFixed(3))
                    });
                }

                this.setPathFromData({ points: pathPoints });
            }

            generateSampleHints() {
                if (!this.currentModel) {
                    alert('Please load a map first to generate sample hints.');
                    return;
                }

                // Get model bounding box
                const box = new THREE.Box3().setFromObject(this.currentModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Generate sample hints at interesting positions
                const sampleHints = {
                    hints: [
                        {
                            title: "Welcome Point",
                            subtitle: "Starting Location",
                            text: "This is the starting point of your virtual tour. From here you can explore the entire environment.",
                            position: {
                                x: center.x - this.modelOffset.x,
                                y: center.y - this.modelOffset.y + 2,
                                z: center.z - this.modelOffset.z
                            }
                        },
                        {
                            title: "Observation Deck",
                            subtitle: "Best Viewpoint",
                            text: "This location offers a panoramic view of the entire scene. Perfect for taking in the surroundings.",
                            position: {
                                x: center.x - this.modelOffset.x + size.x * 0.3,
                                y: center.y - this.modelOffset.y + size.y * 0.5,
                                z: center.z - this.modelOffset.z
                            }
                        },
                        {
                            title: "Hidden Corner",
                            subtitle: "Secret Spot",
                            text: "You've found a hidden area! This spot contains special details that are easy to miss.",
                            position: {
                                x: center.x - this.modelOffset.x - size.x * 0.2,
                                y: center.y - this.modelOffset.y + 1,
                                z: center.z - this.modelOffset.z - size.z * 0.2
                            }
                        }
                    ]
                };

                this.setHintsFromData(sampleHints);
            }

            generateSampleAnnotations() {
                if (!this.currentModel) {
                    alert('Please load a map first to generate sample annotations.');
                    return;
                }

                // Get model bounding box
                const box = new THREE.Box3().setFromObject(this.currentModel);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                // Generate sample annotations
                const sampleAnnotations = {
                    annotations: [
                        {
                            title: "Main Structure",
                            subtitle: "Architectural Feature",
                            text: "This is the main architectural element of the scene. Notice the intricate details and design patterns that make this structure unique.",
                            spherePosition: {
                                x: center.x - this.modelOffset.x,
                                y: center.y - this.modelOffset.y + size.y * 0.5,
                                z: center.z - this.modelOffset.z
                            },
                            sphereRadius: 3.0
                        },
                        {
                            title: "Entrance Portal",
                            subtitle: "Access Point",
                            text: "The main entrance to this virtual environment. This portal symbolizes the beginning of your journey through this digital space.",
                            spherePosition: {
                                x: center.x - this.modelOffset.x - size.x * 0.4,
                                y: center.y - this.modelOffset.y + 1,
                                z: center.z - this.modelOffset.z
                            },
                            sphereRadius: 2.5
                        },
                        {
                            title: "Central Plaza",
                            subtitle: "Meeting Area",
                            text: "A spacious open area designed for gathering and observation. The central plaza serves as the heart of this virtual world.",
                            spherePosition: {
                                x: center.x - this.modelOffset.x,
                                y: center.y - this.modelOffset.y + 0.5,
                                z: center.z - this.modelOffset.z + size.z * 0.3
                            },
                            sphereRadius: 4.0
                        }
                    ]
                };

                this.setAnnotationsFromData(sampleAnnotations);
            }

            requestGyroscopePermission() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(permissionState => {
                            if (permissionState === 'granted') {
                                this.gyroscopePermission = 'granted';
                                this.setupGyroscope();
                                this.updateUI();
                            } else {
                                this.gyroscopePermission = 'denied';
                                alert('Gyroscope access denied. You can still navigate using touch controls.');
                            }
                        })
                        .catch(console.error);
                } else {
                    // Non-iOS devices
                    this.gyroscopePermission = 'granted';
                    this.setupGyroscope();
                    this.updateUI();
                }
            }

            setupGyroscope() {
                window.addEventListener('deviceorientation', (event) => {
                    this.gyroscopeData = {
                        alpha: event.alpha || 0,
                        beta: event.beta || 0,
                        gamma: event.gamma || 0
                    };
                });
            }

            toggleShowAllHints() {
                this.showAllHints = !this.showAllHints;
                const button = document.getElementById('toggle-hints-btn');
                button.textContent = this.showAllHints ? 'Hide All Hints' : 'Show All Hints';
                this.updateHintOverlay();
            }

            togglePlay() {
                this.isPlaying = !this.isPlaying;
                const button = document.getElementById('play-btn');
                if (this.isPlaying) {
                    button.innerHTML = '<span class="icon icon-pause"></span><span>Pause</span>';
                } else {
                    button.innerHTML = '<span class="icon icon-play"></span><span>Play</span>';
                }
            }

            resetCamera() {
                this.currentProgress = 0;
                this.velocity = 0;
                this.isPlaying = false;
                this.updateUI();

                const button = document.getElementById('play-btn');
                button.innerHTML = '<span class="icon icon-play"></span><span>Play</span>';
            }

            toggleUICollapse() {
                const panelContent = document.getElementById('panel-content');
                const collapseBtn = document.getElementById('collapse-btn');
                const icon = collapseBtn.querySelector('.icon');

                if (panelContent.style.display === 'none') {
                    panelContent.style.display = 'block';
                    icon.textContent = '‚Üë';
                } else {
                    panelContent.style.display = 'none';
                    icon.textContent = '‚Üì';
                }
            }

            updateMapLoadStatus(message, status) {
                this.mapLoadStatus.textContent = message;
                this.mapLoadStatus.className = 'text-xs p-2 rounded';

                switch (status) {
                    case 'loading':
                        this.mapLoadStatus.classList.add('status-loading');
                        break;
                    case 'success':
                        this.mapLoadStatus.classList.add('status-success');
                        break;
                    case 'error':
                        this.mapLoadStatus.classList.add('status-error');
                        break;
                }

                this.mapLoadStatus.classList.remove('hidden');
            }

            updateUI() {
                // Update path controls visibility
                const pathControls = document.getElementById('path-controls');
                if (this.curve) {
                    pathControls.classList.remove('hidden');
                } else {
                    pathControls.classList.add('hidden');
                }

                // Update mobile status
                if (this.isMobile) {
                    const gyroStatus = document.getElementById('gyro-status');
                    if (this.gyroscopePermission === 'granted') {
                        gyroStatus.textContent = '‚úÖ Gyroscope enabled';
                        document.getElementById('gyro-prompt').classList.add('hidden');
                    } else {
                        gyroStatus.textContent = '‚ö†Ô∏è Gyroscope disabled';
                        document.getElementById('gyro-prompt').classList.remove('hidden');
                    }
                }
            }

            onWindowResize() {
                if (!this.camera || !this.renderer) return;

                this.camera.aspect = this.canvasContainer.clientWidth / this.canvasContainer.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(this.canvasContainer.clientWidth, this.canvasContainer.clientHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.updateCameraPosition();
                this.updateCameraRotation();
                this.updateHintPositions();

                if (this.renderer && this.scene && this.camera) {
                    this.renderer.render(this.scene, this.camera);
                }
            }

            updateCameraPosition() {
                if (!this.curve) return;

                // Apply acceleration/deceleration for smooth movement
                if (Math.abs(this.velocity) > 0.0001) {
                    this.velocity *= this.deceleration;
                } else {
                    this.velocity = 0;
                }

                // Auto-play if enabled
                if (this.isPlaying) {
                    this.velocity += this.acceleration * this.scrollingSpeed;
                }

                // Clamp velocity to max speed
                this.velocity = Math.max(-this.maxSpeed, Math.min(this.maxSpeed, this.velocity));

                // Update progress along the path
                this.currentProgress += this.velocity;

                // Handle looping (infinite path)
                if (this.currentProgress < 0) {
                    this.currentProgress = 1 + (this.currentProgress % 1);
                } else if (this.currentProgress > 1) {
                    this.currentProgress = this.currentProgress % 1;
                }

                // Get position from curve
                const position = this.curve.getPoint(this.currentProgress);
                this.body.position.copy(position);

                // Calculate look direction (tangent to the curve)
                const tangent = this.curve.getTangent(this.currentProgress);
                if (tangent.length() > 0.001) {
                    this.body.lookAt(position.clone().add(tangent));
                }

                // Update progress UI
                const progressPercent = Math.round(this.currentProgress * 100);
                document.getElementById('progress-percent').textContent = progressPercent;
                document.getElementById('progress-fill').style.width = progressPercent + '%';
            }
        }

        // Initialize the application when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            new VirtualTour();
        });
    </script>
</body>
</html>
